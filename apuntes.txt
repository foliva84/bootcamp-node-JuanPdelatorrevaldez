choco install nodejs.install

uptasknode

https://github.com/juanpablogdl/uptasknode

Dependencias
-------------
Cuando instalas una dependencia crea la carpeta node_modules

Dep. del Proyecto: npm install --save express   -- se guardan en package.json
     Express-> es una dep. de proyecto, por que nuestro proyecto va a estar montado en express,
	           incluso cuando hagamos el deployment en el servidor.
			npm install --save express
	
		Una dep. de proyecto va a acompañar al proyecto desde que lo estoy creando hasta 
		el deployment.
Dep. de desarrollo: existen otras dependencias que solo son necesarias en la etapa de desarrollo. 
     nodemon: nos va ayudar por ejemplo cuando estemos haciendo cambios en los <> archivos, 
	          nodemon va a detectar esos cambios, va a reiniciar el servidor y nos va a mostrar
			  los ultimos cambios.
			  De esa forma podemos estar escribiendo código, agregar más funciones e ir probando mucho 
			  más rápido.
		npm install --save-dev nodemon
	    ¿Por qué esta es una dependencia de desarrollo?
		Por que los cambios en el código, únicamente se van a hacer en la etapa de desarrollo,
		NO se van a hacer en el servidor, por lo tanto termina siendo una dependencia de desarrollo,
		que no va a estar cuando hagamos el deployment, no va a ser parte del proyecto, solamente
		del desarrollo.

		Una dep. de desarrollo entonces solamente van a estar disponibles en la etapa de desarrollo.

Creando el servidor de Express
-------------------------------
Archivo package-lock.json
--------------------------
Es igual al package.json contiene como están relacionadas las dependencias de las dependencias.
Es decir, express tiene dependencias, y nodemon también.

Utilizando npm install
--------------------------
Si eliminamos la carpeta node_modules, y el archivo package-lock.json, y solo dejamos el package.json,
puedo reconstruir las dependencias en la terminal, de la sig. manera:

npm install

escribamos código: creamos un nuevo archivo en la raíz llamado index.js, el cual va a servir para la configuración
-----------------
del proyecto, en el voy a colocar mi aplicación de express, voy a estar agregando algunas dependencias, y muchas otras cosas.
Este archivo, lo estaremos visitando a menudo a lo largo del curso. 

importamos express
------------------
Podemos utilizar la sintaxis ES6 para importar express:
import express from "express";

Esta es la sintaxis nueva para importar, sin embargo, NO es soportada por default,
la puedes habilitar, pero NO por default. 
En express se utiliza algo utilizado require:

const express = require("express"); 

Esto: 
		import express from "express";

y esto: 
		const express = require("express"); 

!Son lo mismo!

Pero express soporta la sintaxis con el require.

creamos la app express
-----------------------
const express = require("express"); 

const app = express(); // uso express como función

la varible app va a contener todo lo necesario por parte de express para crear el servidor.

setear puerto de express
-----------------------
También le podemos decir en que puerto corre express utilizando la función liste() y el número de puerto:

app.listen(3000);

El puerto puede ser cualquiera, solamente nos debemos asegurar que no este ocupado.
Por ej.: si tienes MySql y esta en el puerto 80, y pones el mismo, lo más seguro es que no arranque.
Por lo tanto un puerto seguro es 3000, otras personas le ponen 7000 o 9000 o cualquier número de ese
tipo va a funcionar correctamente. 

arrancar el servidor express
---------------------------
Puedes ver que tenemos ya este servidor, pero tenemos que arrancar el servidor de express.
Para ello en este package.json es que tenemos estos "scripts", y en ellos puedes colocar
o puede conectar lo que tengas en este index.js o en tu proyecto de express con el 
package.json. 
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },

Puedes crear tu propio script, éste es uno de "test", yo usualmente siempre lo borro.
Y voy a crear uno que se llame "start". Muchas personas le ponen "watch", otras 
personas le ponen "dev", puedes nombrarlo como tu desees.
En mi caso le voy a poner "start" para que arranque el servidor, y aquí le pones que 
instrucción va a correr.  
Ahora si recuerdas, mencioné anteriormente que instalabamos nodemon para que detecté 
todos los cambios, cada que yo haga un cambio por ejemplo en una vista, en un controlador,
etc, se reinicia el servidor y me muestra los últimos cambios. 

Por lo tanto vamos a decir que, queremos utilizar nodemon, y debido a que sabe donde esta
almacenado (aquí en node_modules, vas a encontrar una carpeta nodemon también), y después 
le decimos cual va a hacer el punto de arranque, donde va a encontrar la configuración, y 
debido a que estamos en el package.json, y el index.js esta en el mismo nivel, solamente
le ponemos ./index.js:

  "scripts": {
    "start": "nodemon ./index.js"
  },

Va a buscar aquí (./index.js") la configuración, una vez que yo corra el script. 
Si corres estos scripts utilizando npm de tu package.json, si buscas por ejemplo algún 
ejemplo ya hecho de node, lo más seguro es que tengas muchos más scripts, que estaremos
viendolos más adelante con más detalle.

En la terminal ponemos npm que es el comando, luego run y el nombre del script, en nuestro
caso start:
	npm run start 

Ahora start es como que, es muy común, demasiado común que también va a funcionar si le pones nada más:
	npm start
	
Ejemplo:

user@DESKTOP-VI2L807 MINGW64 /c/proyectos/bootcamp-node/UpTaskNodeJS
$ npm start

> uptasknodejs@1.0.0 start
> nodemon ./index.js

[nodemon] 2.0.15
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,json
[nodemon] starting `node ./index.js`

Puedes ver que me dice aquí que ha comenzado el servidor de node, si recuerdas le 
dimos que tiene que escuchar en el puerto 3000. 
Accedes a tu proyecto de node poniendo en un navegador:

http://localhost:3000/ 

Puedes ver:
	Cannot GET /
que nos dice que no puede obtener la ruta diagonal.

Pero no hay ningún problema, eso quiere decir que se ha creado el servidor de express.

Es mucho más sencillo, puedes ver que son nada más que 3 líneas para configurar un servidor
de express.

Si lo crearamos todo nosotros sería mucho más código, y no le veo sentido en realidad. 
Sería código que nunca utilizarías en tu vida. 


configurando una ruta para el home
Aquí le vamos a decir, o aquí vamos a configurar que se va a ver cuando 
yo entro en lo que viene siendo esta página, cuando yo abro:

http://localhost:3000/

Para ello defines algo que se llama "rutas", una ruta para la home.

Aquí voy a usar use() que es lo que se conoce como el middleware 
de express. 

Piensa en el middleware en funciones que se ejecutan una tras otra.
Más adelante estaremos viendolo más a detalle.

	app.use("/", (req, res) => {
		res.send("Hola");
	});

Básicos del Router
-------------------------------
En el vídeo anterior configuramos ya lo que viene siendo el servidor
de express, tenemos una parte que es configuración de express, y tenemos
una ruta hacia la home.

	app.use("/", (req, res) => {
		res.send("Hola");
	});

Y utilizamos este .use() y este .send(), y tal vez tengas dudas de que son.
Todo esto es parte de lo que viene siendo por así decirlo parte del lenguaje, 
de express.
Que son funciones que existen en express, y por ejemplo .use(), esto lo que 
hace es que, cualquier request, hay muchos request en HTTP, están los de POST,
están los de GET, están los de PATCH, los de DELETE, etc; cualquier request
va a correr este código, cuando tienes .use() cualquiera de todos los request, 
corre este código. 

Puedes ponerle aquí .get(), y solamente cuando tengamos el request de GET,
va a imprimir Hola.

	app.get("/", (req, res) => {
		res.send("Hola");
	});

Pero por ejemplo si tuvieramos un formulario aquí, con el método de POST, 
y yo enviará datos al formulario éste no correría por que utilizaría .get() 
- éste es el código anterior. 
Pero si lo pones como .use() va a leer tanto GET como POST, y cualquier 
otro verbo de HTTP. 

Para este punto .send() lo que imprime es solamente esto ( Hola ).
Supongamos que estas creando una REST API y realizas una consulta a una BD - 
que es algo que veremos mucho más adelante, y supongamos que tenemos
un arreglo de productos (que es lo que te devolvería una consulta a una BD):

const productos = [
	{ 
		producto: "Libro",
		precio: 40
	},
	{ 
		producto: "Computadora",
		precio: 10000
	}	
];

y ahora send() envia ese array:

	app.get("/", (req, res) => {
		res.send(productos);
	});

Imprime o nos da una respuesta como una arreglo:
[{"producto":"Libro","precio":40},{"producto":"Computadora","precio":10000}]

Pero también puedes en una REST API se recomienda utilizar .json():

	app.get("/", (req, res) => {
		res.json(productos);
	});

y eso te va devolver la respuesta como JSON.

¿Cuál es la ventaja de este JSON? Qué lo puedes consumir en otro proyecto
de Angular, o de VUE, o de React, o cualquier otro.

Puedes acceder a datos desde otra aplicación, y eso es lo que hace esta parte 
de aquí - res.json(productos), es como se van a mostrar los datos.

send() es la respuesta más básica, 
y json() más adelante veremos como mostrar HTML, 
y para ello se utiliza .render()

El primer proyecto esta pensado para utilizar como vista, por eso 
el .render() se utiliza para las vistas, un motor que se llama pug

Espero haya quedado más claro el uso del .use() y el uso del .send().

Lo que viene siendo el request y el response, lo veremos más a detalle 
conforme vayamos avanzando.

Solamente ten en cuenta esto, request es la consulta que tu haces 
cuando le das por ejemplo ENTER, o realizas una inserción de un 
formulario. Eso viene siendo el request.

El response es que te devuelve el servidor, en base a lo que tu hiciste
request.

Por ejemplo si yo hablo la página principal, la respuesta del servidor es ponerme
un Hola, y aquí esta, es parte de la respuesta.

En el siguiente vídeo vamos a continuar trabajando, la idea es comenzar a crear
el proyecto desde ya, tampoco vamos a perder el tiempo, en una introducción
de 100 vídeos, y 5 vídeos de proyecto, no es mi tipo de enseñanza.

En el sig. video vamos a comenzar a crear lo que viene siendo la estructura 
de este proyecto.

Creando un Archivo de Rutas
-------------------------------------------
intro
------
Actualmente nuestro proyecto solamente cuenta con una sola ruta, 
lo más seguro es que si estás creando por ej, un sitio web o una
aplicación tengas <> rutas.

Un ejemplo muy sencillo podría ser:

app.use("/nosotros", (req, res) => {
    res.send("Hola");
});

/nosotros, /contactos, /blog, etc, sería muchas rutas las que
tendría tu sitio web.

El detalle de hacer algo así o en este archivo (./index.js), 
es que puedes ver que nada más tenemos uno (un solo archivo .js),
es que este archivo muy pronto estará muy desordenado, tendrías
mucho código, que bien podría ir en otro archivo.

Y para eso tenemos que crear <> carpetas.
Usualmente todo lo que son las rutas, se recomienda tenerlo
en una carpeta llamada /routes, y aquí dentro voy a poner un 
index.js (./routes/index.js).

Siempre se recomienda tener esa seperación, por eso también 
vamos a utilizar Model View Controller - MVC, para etner esa separación,
lo que se conoce como separación de responsabilidad, donde c/parte 
de la aplicación hace algo. 

Para poder definir estas rutas la sintaxis va a hacer un poco diferente,
por que si nada más cortas y lo pegas aquí, no va a funcionar de la misma 
forma (el contenido de lo que tenemos en ./index.js):

	// ruta para el home 
	app.use("/", (req, res) => {
		res.send("Hola");
	});

	app.use("/nosotros", (req, res) => {
		res.send("Hola");
	});

Por ejemplo aquí puedes ver que dice app.use(), pero este app no esta 
dispnible en este archivo, y NO podemos crear otra INSTANCIA de express.

usar express router
-------------------
Por lo tanto para ello se utiliza algo que se conoce como Express router,
entonces al principio de index.js (./routes/index.js) vamos a escribir:

const express = require("express");
const router = express.Router();

exportar express router
------------------------
Tenemos que hacer dispnibles lo que vienen siendo estás rutas:

	// ruta para el home 
	app.use("/", (req, res) => {
		res.send("Hola");
	});

	app.use("/nosotros", (req, res) => {
		res.send("Hola");
	});

Todo este contenido, lo que está aquí, hacerlo disponible hacia
acá (./index.js).

Y si has utilizado la nueva sintaxis de ES6, usualmente se utiliza
export default y luego el nombre del objeto, de la función que vas a
exportar.

De nueva cuenta esta sintaxis, no es soportada de forma nativa, NO!
Pero a module.exports:

const express = require("express");
const router = express.Router();

module.exports = function() {
    // ruta para el home 
    router.get("/", (req, res) => {
        res.send("Index");
    });

    router.get("/nosotros", (req, res) => {
        res.send("Nosotros");
    });
	return router;
};

Entonces cuando yo entre en la página principal o en 
/nosotros, por medio de GET, se van a mostrar Index o Nosotros.

importar rutas en ./index.js
-----------------------------
const routes = require("./routes");

No es necesario poner el index.js, por que se da por implícito de que
se va a importar.

Luego agregamos:
	app.use("/", routes());

- routes va con paréntesis por que lo que importamos desde routes, es 
una función:

const express = require("express");
const routes = require("./routes");

// crear un app de express
const app = express();

app.use("/", routes());

app.listen(3000);

Y de esta forma podemos crear múltiples páginas e ir accediendo
a <> secciones, crear un sitio web con múltiples secciones o 
una aplicación con <> secciones.

Puedes ver que tenemos nuestro archivo de rutas, y tenemos
este request y response (req y res), y nos dice que se tiene que 
mostrar.

Eso en el MVC es obligación del Controller, no es obligación de 
la ruta.

Por lo tanto en el siguiente video vamos a crear la parte 
de los controladores, para definir esta estructura que tenemos
aquí.

Que es Model View Controller - MVC
-------------------------------------------
intro
------
Los proyectos desarrollados en este curso utilizan el patrón MVC,
lo que se conoce como Model View Controller, en español 
Modelo Vista Controlador.

Veamos brevemente que és Model View Controller (MVC).
Es un patrón de diseño de software que permite la separación de 
aplicaciones, así se le conoce a cada pieza, que tiene como 
una obligación, y solamente se dedica a cumplir esa obligación.

Con <> de otras formas de escribir código, en la que la consulta a la
BD, el código PHP por ejemplo y el HTML se revuelven, en el MVC no se
hace de esa forma. 

Cada pieza es separada, cada pieza realiza una función, y solamente esa,
y bueno se realiza en tu aplicación web.

Acá dice en tu aplicación web, por que el curso se enfoca a desarrollo web,
pero también hay MVC para desarrollo de aplicaciones mobiles por ejemplo.

Enfatiza la separación de la lógica de programación y lo que se muestra en una
pantalla, es decir lo que se muestra - los datos, son o se almacenan en una
vista, pero esos datos vienen de algo que se conoce como el modelo.

Entonces son 3 piezas, 

	Model es igual a Modelo,
	View es igual a la Vista, y 
	Controller es igual a Controlador.

Estare utilizando estos términos de forma o mejor dicho los estaré cambiando,
es decir, algunas veces me voy a referir a Model o a Modelo, es exactamente lo mismo.

Modelo
------
Primero veamos que es el Modelo o el Model. 
Es el encargado de los datos - usualmente viene de una BD, por lo tanto es en el 
Modelo donde realizas las consultas y de toda la lógica para mostrar esos datos.

Es decir, el modelo va a contar con una serie de métodos para realizar la consulta
a la BD, pero también es el que le da la forma a los sujetos, es decir si yo tengo,
un modelo para clientes, bueno voy a colocar ahí por ejemplo un Id, el nombre del 
cliente, que tipo de cliente es y en que categoría esta; alguna imagen del cliente,
su teléfono de contacto, toda la forma del objeto de clientes se la va a dar el 
modelo.

Veamos un ejemplo...
Supongamos que un usuario visita la sección de productos, que es una tienda virtual.
Ahí hay muchas cosas que suceden, es decir, el modelo va a encargarse de realizar 
la consulta, pero toda la parte visual es algo que lo hace la vista, entonces 
ahí tenemos un poco la separación de obligaciones.

El modelo únicamente se encarga de traer los datos desde la BD, mientras que lo que
se ve en pantalla, corresponde a lo que se conoce como la vista.

Vista
------
La vista es la que se encarga de todo lo que se ve en la pantalla (HTML), es 
decir todo el HTML.

Ejemplo:
y bueno volviendo al ejemplo anterior, si el modelo hace la consulta a la BD, 
se traen los resultados de la BD para los productos. 
Es la vista la que muestra esos resultados, es el HTML, es la parte visual.


Controller
------------
Y finalmente tenemos el Controller. 
Es el que se comunica entre el Modelo y la Vista, muy importante.
Es decir tu visitas /productos, se comunica con el modelo y dice: 
"oye un usuario esta visitando productos, pasame todos los productos,
y lo que viene siendo el modelo se regresa al controlador".

Dice: "acá están los productos", y el controlador se lo pasa hacia la vista
para que se vean.

Se puede decir como la persona en medio, es lo que comunica, lo que viene
siendo los datos de la BD, ya con lo que se ve en el HTML.

Es como lo que esta ahí a medias, como el medio de comunicación entre ambos.

Y bueno antes de que el modelo consulte la BD, es el encargado de mandar
a llamar el modelo, y decirle o esperar a que tenga los resultados, y el 
modelo una vez que tiene los resultados de la consulta a la BD, se los
regresa, lo que viene siendo el controlador para que éste los pase hacia
la vista.

Router
--------
Un término que se menciona poco, en MVC, pero en express se utiliza mucho
y otros frameworks como Laravel, es el Router, o lo que viene siendo
las URLs reales de un sitio web.

Es el encargado de registrar todas las URLs's o endpoints que soporta
tu aplicación, y en base a que el usuario visite esas URL's, se realizan
ciertas acciones. 

Por ejemplo, si el usuario accede a /productos, bueno el Router manda a llamar
al controlador, le dice, alguien esta visitando, haciendo uso de la aplicación,
es tu problema que pase de aquí en adelante.

El controlador se comunica con el modelo, le dice que es lo que tiene que 
consultar, obtiene los datos del modelo, que se pasan de regreso hacia el controlador,
es decir, controlador y modelo para mandarlo a llamar y después obtener los datos;
y finalmente es el controlador quien le pasa los datos hacia la vista para
que se muestren.

Creando el Controlador de los Proyectos
-------------------------------------------
Vamos a crear la parte del controlador que nos va a mostrar, lo que viene siendo
el index y nosotros.

Aquí en la raíz del proyecto voy a crear una nueva carpeta que voy a nombrar como
controllers.

El controlador es lo que va a estar en la parte de a medias, por así decirlo,
del modelo y de lo que viene siendo la vista... El controlador es lo que conecta
a ambas partes.

En este caso nuestro Router (./routes/index.js), puedes ver que definimos las rutas,
pero también esta parte de código, la segunda parte de lo que viene siendo el router,
nos dice que se va a mostrar, en la parte del HTML, esto es obligación del controlador.

Creamos el archivo proyectosController.js en ./controllers: 

exports.proyectosHome = (req, res) => {
    res.send("Index");
};

Luego importamos proyectosController en ./routes/index.js:

const express = require("express");
const router = express.Router();

// importar el controlador
const proyectosController = require("../controllers/proyectosController");

module.exports = function() {
    router.get("/", proyectosController.proyectosHome);

    router.get("/nosotros", (req, res) => {
        res.send("Nosotros");
    });
    return router;
};

De esta forma lo que viene siendo tu Router, funciona únicamente como router,
y el controlador es el que define, que se va a ver, que se va a mostrar, en 
lo que viene siendo el HTML, que de momento solamente tenemos estos send()
pero la idea es ir agregando vistas ...

Y para ver algo diferente, que no sea nada más ese texto, tenemos que
configurar lo que viene siendo la parte de las vistas del MVC. 

Así que en el siguiente video vamos a configurar las vistas.

Este primer proyecto esta hecho con PUG, así que continuamos en el próximo video.

Qué es el Template Engine
-------------------------------------------
En este vídeo vamos a ver que son los Template Engines o también se les conoce cómo
motores de plantilla.

¿Qué son?
Son la V (Vista) del MVC.

Permiten mostrar la parte visual (HTML) en una aplicaciones express - y bueno en realidad
en cualquier otro framework que decidas utilizar, casi todos tienen su propio Template Engine.

Debido a que el modelo retorna un objeto ( o también puede ser un arreglo ) de datos, 
un Template Engine te va permitir acceder a los resultados de una consulta y también
mostrarlos en la pantalla.

Caract. de un Template Engine
----------------------------------
Hay una gran variedad y c/u tiene su propia sintaxis.
Usualmente puedes escribir código JS dentro del HTML 
   - es decir, si hiciste una consulta por ejemplo para productos, la obtuviste del modelo,
     los datos en el controlador lo pasa a la vista, y tienes 100 productos ... puedes
	 iterar en esos 100 productos en lo que viene siendo la vista, con un for each,
	 y es un código JS, e ir imprimiendo el resultado de esa consulta en lo que 
	 viene siendo tu vista al final. 
	 Se puede decir que se "compila" y termina siendo un código HTML plano, 
	 pero en la parte de desarrollo termina siendo de gran ayuda porque
	 simplifica mucho como se van a imprimir los datos.
Si tienes experiencia en Angular, Reac o Vue, usualmente reemplazan estos 
Template Engines en una aplicación de Node.

Lo más comunes en Node-Express
----------------------------------
PUG ( Antes JADE )
   - Bastante limpio en la forma en la que queda el template
EJS - Embedded JavaScript
HBS - Handlebars.js (Mustache.js)
   - Este era como un sistema de templates en JavaScript bastante común
     hace muchos años, y hoy en día sigue siendo bastante popular.
     Se fusiona con Mustache.js - que también es bastante bueno, 
	 entonces son excelentes opciones.
     Todos los proyectos están hechos con algunos de estos, la idea es que
     te sientas familiarizado con alguno de ellos, aprendas, veas con cual
     te siente más cómodo escribiendo código, aprendas sobre todo los 3, y 
     de ahí tu decidas cual crees que es el mejor.
- React 
   - También existe un Template Engine para React que es bastante común.

Un Template Engine se instala vía npm
---------------------------------------
   npm install pug

y se habilita en el archivo principal
   // habilitar pug
   app.set("view-engine", "pug");

   El 2do parámetro dice "pug", pero puede cambiar ... depende el Template que
   hayas decidido utilizar, puede que sea pug como en este caso, puede que
   sea hbs, o también puede que sea ejs.

Finalmente veamos un poco la sintaxis de cada uno.

Ejemplo PUG
-------------

   if tareas.length
      each tarea in tareas
	       li.tarea(data-tarea=`${tarea.id}`)
		      p= tarea.tarea

	Etiquetas de apertura y cierre generadas automáticamente.

Ejemplo Handlebars
-------------------
	<div class="caja">
		<p class="etiqueta">Empresa</p>
		<p class="nombre">{{ vacante.empresa }}</p>  
	</div>
	<div class="caja">
		<p class="etiqueta">Ubicación</p>
		<p class="nombre">{{ vacante.ubicacion }}</p>  
	</div>

	Etiquetas de aperturas y cierre son necesarias.
	Lo que es dinámico lo ponemos dentro de estas dobles llaves, y 
	después el nombre del objeto para ir imprimiendo c/u de ellos.

Esta sintaxis se puede sentir un poco más familiar en la parte del HTML.

Ejemplo EJS
-------------
	<div class="informacion-usuario">
		<div class="imagen">
			<% if (usuario.imagen) { %>
				<img src="/uploads/perfiles/<%= usuario.imagen %>" />
			<% } %>   
		</div>
		<div class="texto">
			<%- usuario.descripcion %>
		</div>
	</div>

Nota como en este caso sigue siendo el HTML con etiqueta de apertura y cierre.
Pero x ejemplo digamos esta parte que esta debajo de esta div class="texto"
ahi tenemos <%- usuario.descripcion %>, usuario es el objeto principal,
pero nota esta sintaxis de menor que, luego porcentaje, luego un guión medio,
Eso es lo que va a decir, bueno ignora que esto sea un HTML, esto es una 
variable de JS, imprimimelo como tal, es dinámico, viene de la BD, imprimelo
como tal.

Ahora nota por ejemplo esa parte que dice usuario.descripcion como tiene un guión
medio, y arriba el if no lo tiene. 

Cuando le colocas un guión medio o un signo de igual eso quiere decir imprimelo,
cuando no colocas nada eso quiere decir evalúa el código JS; y nota como 
evaluamos si hay una imagen, entonces imprimimos la imagen.

Y nota como por ejemplo aquí donde dice usuario.imagen tenemos un signo igual.

La <> entre esto 2, guión medio y signo igual, en realidad no es mucha.
Uno se conoce como están los datos escapados, y el otro no.

Finalmente el curso incluye:
Cada proyecto hecho con un template engine diferente.
   -- El 1° esta hecho en PUG
   -- El 2° con Handlebars
   -- El 3° esta hecho con EJS

Finalmente tendremos algo de React pero no como Template Engine.

Con todos puedes lograr / mostrar lo mismo, así que utiliza 
el que se sienta más natural.

Una vez que hayas finalizado el curso y finalmente si quieres leer
un poco más, en esta URL hay una gran cantidad de Template Engine
soportados por express:

https://github.com/expressjs/express/wiki#template-engines

https://expressjs.com/en/resources/template-engines.html

No hay nada más que 3, son como 20, pero estos son lo más comunes 
hoy en día.

Instalando Pug y habilitando las Vistas en Express
------------------------------------------------------
Actualmente sino en nuestro sitio web abrimos nosotros o abrimos
la página de inicio, solamente tenemos este texto:

Inicio

Estamos utilizando lo que viene siendo .send():
	exports.proyectosHome = (req, res) => {
		res.send("Index");
	};

, y .send() solamente va a mostrar lo que este dentro del paréntesis().

Si tu proyecto va a crecer y quieres que se vea más atractivo a la vista,
lo más seguro es que quieras agregar algo de HTML, CSS.

Y la forma en que lo haces es agregando la parte, ya tenemos el controlador,
tenemos que agregar la parte de las vistas.

Y existen muchas formas de agregar vistas en express.

Casi siempre se utiliza un lenguaje de template, un template engine.
Existen una gran variedad que puedes utilizar con express.
Puedes ver en esta lista, tienes todos estos que están aquí, de los que
puedes utilizar con express:

https://expressjs.com/en/resources/template-engines.html

En este curso estaremos utilizando estos 3:
- Pug
- EJS
- Handlebars

En mi opinión son los 3 más comunes, más populares, y existe buena
posibilidad de que si te toca mantener un proyecto de express, 
o alguien ha iniciado algo, cualquiera de estas 3 sea la opción que 
hayan decidido utilizar.

instalando pug
--------------
Primero tenemos que instalar pug, para eso vamos a detener el servidor
en lo que es la consola y escribimos:

   npm install --save pug

   (va a hacer una dependencia del proyecto)

Una vez se haya terminado de instalar, volvemos a correr el servidor con:
   npm run start

haciendo algunas modificaciones (./index.js)
-------------------------------
Después tenemos que abrir el archivo - ./index.js,
si recuerdas mencioné que este archivo, en el vamos a estar trabajando,
y es como el archivo de configuración.

Y esta vez vamos a agregar 2 cosas:

1°) Vamos a habilitar pug como el view-engine
2°) Vamos a agregar la carpeta de las Vistas

Muy importante, puedes ver que aquí dice crear una app en express:

	// crear un app de express
	const app = express();

, por tanto debe de ser después de esta línea:

	// Habilitar pug
	app.set("view engine", "pug");

Ahora creamos la carpeta views en la raíz del proyecto (./views),
y con esto ya tenemos las carpeta controllers y views listas, solo nos faltan
los modelos, eso lo veremos mucho más adelante.

Para poder decirle a express que queremos leer esta carpeta, 
tengo que importar algo llamado el path:

	const path = require("path");

path es una librería que ya existe en node, por lo tanto no tienes 
que instalar nada; y path lo que hace es leer lo que se conoce como 
el file system, es decir los archivos que existen en tu carpeta - 
es una forma de acceder a ellos, y aquí le decimos que lo agregue 
a la vistas:

	// Añadir la carpeta de las vistas
	app.set("views", path.join(__dirname, "./views"));

__dirname: nos va a retornar el directorio principal - que vendría
siendo en donde esta el ./index.js.

pruebas sobre ./views
-------------------------------
Agregamos una vista en ./views que se llame index.pug -
muy importante tiene que ser punto pug, no se va a utilizar 
.html, ni nada de eso ... se va a utilizar .pug para crear 
lo que vienen siendo los templates. 

Rellenamos index.pug con:

h1 Hola

En ./controllers/proyectosController.js, vamos a utilizar 
el método .render() en lugar del .send() - como parámetro recibe
el nombre de la vista:

exports.proyectosHome = (req, res) => {
    res.render("index");
};

Eliminando ruta ./nosotros
-----------------------------
Eliminamos la ruta hacia ./nosotros del archivo ./routes/index.js:

    router.get("/nosotros", proyectosController.nosotros);

La eliminamos también del controller (./controllers/proyectosController.js):

	exports.nosotros = (req, res) => {
		res.send("Nosotros");
	};

lo que sigue
-------------
En el siguiente video veremos como crear lo que se como conoce
como una Master Page, es decir una página principal que va a
tener toda la parte del HTML para el header, los scripts, 
enlace a hojas de estilo, entre otras cosas. 

Es decir creamos el layout principal.

Creando un Master Page
------------------------------------------------------
En el vídeo anterior ya hemos habilitado lo que son las vistas
en nuestro proyecto.

Ahora veamos la importancia de 2 cosas:

1°) Por que crear un Master Layout
2°) También veremos la parte de los archivos públicos

primeros pasos
---------------
Primero vamos a abrir lo que vienen siendo los routes, y puedes
ver que es nuestro controlador, tenemos lo que viene siendo
la página principal, agreguemos una ruta a /nosotros:

    router.get("/nosotros", (req, res) => {
        res.render("nosotros");
    });

y ahora creemos la vista nosotros.pug dentro de la carpeta ./views,
con el siguiente contenido:

h1 Nosotros

En ./views/index.pug reemplazamos su contenido por el siguiente:
h1 Index

importancia del layout
-----------------------
Es importante definir un Layout o un Master Page, por que supongamos
que en index.pug, pones un ! (signo de exclamación), más un TAB,
te agrega un HTML, y entonces agregamos una hoja de estilo,
suponiendo que tiene algo así como un link (por ej a bootstrap.css),
tendría que hacer eso mismo en todos tus archivos.

Eso a la larga no es fácil de mantener, porque si tienes 50 vistas, y 
te piden agregar una nueva hoja de estilo, tendrás que hacerlo 50 veces,
pero si te dicen que la quites tendrás que hacer lo mismo 50 veces.

Y esto se soluciona muy fácilmente con algo llamado Layout o Master Page.

Es muy sencillo de crear y veremos sus ventajas.

creando el layout
-------------------
En la raíz de la vistas vamos a crear un nuevo archivo llamado 
layout.pug.

Nota aparte, recién utilizamos el signo de exclamación más un TAB,
y nos deplegó todo un snippet inicial de la estructura HTML
de una página.

Para poder utilizar otros snippets, en VS Code -- Extensions, 
buscamos e instalamos la siguiente extensión:

Pug/Jade snippets for VS Code

doctype html
html(lang="en")
    head
        meta(charset="UTF-8")
        meta(http-equiv="X-UA-Compatible", content="IE=edge")
        meta(name="viewport", content="width=device-width, initial-scale=1.0")
        link(rel="stylesheet", href="./css/bootstrap.css")
        title Document
    body 
        block contenido

        block despuesContenido

archivo ./views/nosotros.pug
extends layout 

block contenido
    h1 Nosotros

block despuesContenido
    h2 Yo voy después del contenido    

archivo ./views/index.pug
extends layout 

block contenido
    h1 Inicio

para terminar el video
-----------------------
el archivo ./views/nosotros.pug lo voy a eliminar, solo 
lo utilize para mostrarles las ventajas de utilizar una Master Page.

También eliminamos la referencia a la vista nosotros desde 
./routes/index.js:

    router.get("/nosotros", (req, res) => {
        res.render("nosotros");
    });

En ./views/layout.pug eliminamos el bloque despuesContenido.

sobre los recursos de este video
---------------------------------
Puedes ver que en los recursos del vídeo deje un archivo llamado
public.zip.

Esta carpeta hay que abrirla, luego abrir nuestro proyecto,
y moverla hacia el mismo.

Puedes que nuestro proyectos ya tendremos:
	- controllers
	- un public
	- un routes 
	- y un views 

Usualmente en esta carpeta de public vas a colocar tus archivos 
de JavaScript, CSS, imagenes, etc, 

En ./public/css vas a encontrar 2 archivos:
	- app.css
	- normalize.css

Entonces desde ./views/layout.pug vamos a hacer referencia a estos 2 
archivos:

	link(rel="stylesheet", href="/css/normalize.css")
	link(rel="stylesheet", href="/css/app.css")

Si guardamos cambios y recargamos, puedes ver que no los toma,
incluso si abres aquí tu consola te van a aparecer un par de errores:

Refused to apply style from 'http://localhost:3000/css/normalize.css' because its MIME type ('text/html') is not a supported stylesheet MIME type, and strict MIME checking is enabled.
Refused to apply style from 'http://localhost:3000/css/app.css' because its MIME type ('text/html') is not a supported stylesheet MIME type, and strict MIME checking is enabled.

Te va a decir que no encuentra ni:
	- normalize.css
	- app.css

Y eso es por que tenemos que ir al archivo de configuración de node, 
y decirle en que carpeta va a encontrar esos archivos.

Así que todo eso lo veremos en el próximo video.

Habilitando los Archivos Estáticos y finalizndo el Master Page
----------------------------------------------------------------------
En el vídeo anterior agregamos lo que viene siendo tanto normalize.css como 
app.css.

- normalize.css: nos va a resetear algunos estilos por default de los navegadores.
- app.css: contiene los estilos para este proyecto.

Para no estar escribiendo todo el css, ya lo incluí como material del curso.

Pero puedes que nos aparece un error, nos dice que no encuentra lo que 
viene siendo estas carpetas - las agregamos en la carpeta public, es 
una recomendación, es como una convención que hay de nombrarla como 
public, pero tu puedes nombrarla com otu desees. 

Por que tienes que decirle a node en que parte va a encontrar esos archivos, y eso
lo haces de nueva cuenta en el ./index.js.

Aquí después de crear la aplicación de express, vamos a decirle
donde cargar los archivo estáticos:

	// Donde cargar los archivos estáticos
	app.use(express.static("public"));

finalizando la Master Page
---------------------------
./views/layout.pug
doctype html
html(lang="en")
    head
        meta(charset="UTF-8")
        meta(http-equiv="X-UA-Compatible", content="IE=edge")
        meta(name="viewport", content="width=device-width, initial-scale=1.0")
        link(rel="stylesheet", href="./css/normalize.css")
        link(rel="stylesheet", href="./css/app.css")
        //- title= nombrePagina
        title #{nombrePagina}
    body 
        header.barra 
            h1 UpTask - Administrador de Proyectos 
            a(href="#") Cerrar Sesión

        main.contenedor
            aside.contenedor-proyectos
                .panel.crear-proyecto
                    a(href="#" class="boton") Nuevo Proyecto
                        span +
                .panel.lista-proyectos
                    h2 Proyectos 
                    ul#proyectos.proyectos
                        li
                            a(href="#") Diseño de Tienda Virtual
                        li
                            a(href="#") Diseño de Nuevo Blog
                        li
                            a(href="#") Diseño de Tienda Logotipo                            
            
            block contenido

para cambiar el titulo del layout
----------------------------------
En ./controllers/proyectosController.js:

	exports.proyectosHome = (req, res) => {
		res.render("index", {
			nombrePagina: "Proyectos"
		});
	};

En el método render() usamos el 2° parámetro, el cual recibe un objeto.
En este caso le pasamos la propiedad nombrePagina.

Luego desde ./views/layout.pug para referenciarlo se puede 
hacer de 2 formas:

1°) Usando el signo igual espacio y el nombre de la propiedad, luego de title

	title= nombrePagina

2°) Usando # y entre llaves poner el nombre de la propiedad, luego de title

	title #{nombrePagina}

lo que sigue
-------------
Puedes ver que agregamos este botón de Nuevo Proyecto.
No hace nada de momento, por que si abrimos lo que viene siendo el 
layout, pero ver que nada más dice aquí, en el href="#":

	a(href="#" class="boton") Nuevo Proyecto
		span +

Tenemos que crear una nueva ruta en ./routes/index.js, y 
crear una nueva vista.

Veamos como hacer esa parte en el próximo video.

Creando la sección para Nuevos Proyectos
------------------------------------------
Continuemos con nuestro proyecto, vamos a abrir ./views/layout.pug,
aquí donde tenemos este botón que dice Nuevo Proyecto, el enlace aún
no funciona:
	.panel.crear-proyecto
		a(href="#" class="boton") Nuevo Proyecto
			span +

tiene el signo de gato (#) solamente para simular el enlace, así 
que vamos a ponerle entre comillas /nuevo-proyecto:
	.panel.crear-proyecto
		a(href="#" class="boton") Nuevo Proyecto
			span +

Si guardamos y vamos http://locahost:3000/ y hacemos clic en Nuevo Proyecto,
vemos que nos devuelve que no puede encontrar esa ruta:

Cannot GET /nuevo-proyecto

Eso pasa por que cuando creas nuevas rutas así, tienes que ir al router,
y definir también esas rutas para que express sepa que existen.

Entonces en ./views/layout.pug, colocamos la ruta hacia /nuevo-proyecto:
	.panel.crear-proyecto
		a(href="./nuevo-proyecto" class="boton") Nuevo Proyecto
			span +

Luego vamos a ./routes/index.js y también incluimos la ruta:

	module.exports = function() {
		router.get("/", proyectosController.proyectosHome);
		router.get("/nuevo-proyecto", proyectosController.formularioProyecto);
		return router;
	};

En ./controllers/proyectosController.js:
	exports.formularioProyecto = (req, res) => {
		res.render("nuevo-proyecto", {
			nombrePagina: "Nuevo Proyecto"
		});
	};

En ./views vamos a crear un archivo nuevo: 
	- nuevo-proyecto.pug

En nuevo-proyecto.pug poner el siguiente contenido:
extends layout 

block contenido
    .contenido-principal
        h1 #{nombrePagina}

En index.pug para dejarlo similar a nuevo-proyecto.pug colocamos 
lo siguiente:

extends layout 

block contenido
    .contenido-principal
        h1 #{nombrePagina}

para finalizar
---------------
Entonces cada vez que hay que agregar una nueva ruta son 3 cosas las 
que tenemos que tener en cuenta:

	- 1°) Agregarlo en el routes (./routes/index.js)
	- 2°) Definir la parte del controlador
	- 3°) Agregar la vista

Tenemos lista ya la nueva vista para ./nuevo-proyecto, nos hace
falta un formulario. 

Todo eso lo veremos en el próximo video.

Creando el Formulario para nuevos Proyectos
--------------------------------------------
Continuamos con nuestro proyecto.

Vamos a agregar aquí un formulario (./views/nuevo-proyecto.pug).

Va a hacer un formulario muy sencillo porque solamente le vamos a 
agregar un nombre de proyecto, y botón de submit para enviar.

Entonces cuando el usuario haga click en el botón Agregar,
nosotros tenemos que hacer algo. 

Puedes ver que si nosotros abrimos nuestro ./routes/index.js,
tenemos .get():

	router.get("/nuevo-proyecto", proyectosController.formularioProyecto);

.get() es cuando yo abro la página o cuando accedo a la misma.

Pero cuando mandas datos por un formulario usualmente se utiliza 
un método llamado post().

Por lo tanto tenemos que venir a nuestro router, y agregar
lo que viene siendo el router o la ruta para el post():

Veamos como hacerlo en el próximo video.

archivo nuevo-proyecto.pug
---------------------------
extends layout 

block contenido
    .contenido-principal
        h1 #{nombrePagina}

        form.agregar-proyecto
            .campo
                label(for="nombre") Nombre Proyecto:
                input(type="text" id="nombre" name="nombre" placeholder="Nombre Proyecto")
            .campo.enviar
                input(type="submit" value="Agregar" class="boton")

Enviando los datos de un formulario en Express
-----------------------------------------------
En este vídeo vamos a crear la parte del controlador, y también lo que viene 
siendo la ruta cuando el usuario agrega aquí el nombre del proyecto, y le 
de a agregar.

Eso usualmente se hace con el método de post().

Si abrimos aquí nuevo-proyecto.pug, vemos que aquí nuestro 
form no tiene nada (es decir no tiene action), por lo tanto vamos 
a agregarselo:

	form.agregar-proyecto(action="./nuevo-proyecto" method="POST")

En ./routes/index.js:

	module.exports = function() {
		router.get("/", proyectosController.proyectosHome);
		router.get("/nuevo-proyecto", proyectosController.formularioProyecto);
		router.post("/nuevo-proyecto", proyectosController.nuevoProyecto);
		return router;
	};

Luego en ./controllers/proyectosController.js:
	exports.nuevoProyecto = (req, res) => {
		res.send("Enviaste el formulario");
	};

Por lo tanto puedes definir vistas para la parte del GET como para 
la parte del POST, aunque sea la misma URL.

Lo que viene siendo el Router se encarga de eso, puede ser 
que la URL es la misma, pero uno reacciona a GET y no a POST, 
y c/u tiene controladores <>.

En ./controllers/proyectosController.js, vamos a quitar la 
parte del .send():

	exports.nuevoProyecto = (req, res) => {

	};

lo que sigue
-------------
En el siguiente video vamos a ver como acceder a lo que el usuario
escriba en esta parte (parte donde se recepcionan los datos, 
donde se envia el formulario), como podemos acceder y leer 
esos valores, y ya nos estamos acercando un poco 
a la parte donde vamos a insertar los registros en BD, 
así que vamos a continuar en el próximo video, y veamos
como leer lo que el usuario agregue en este input.

Leyendo los datos de un formulario en Express
-----------------------------------------------
Veamos como leer lo que el usuario escriba en este formulario,
va a ser importante por que de esta forma, si por ejemplo yo pongo
Diseño de Tienda Virtual, y le doy a agregar, necesitamos
leer ese valor para insertarlo en la base de datos.

Pero también necesitamos validar un poco para que el usuario 
no agrege algo vacio.

Pues vamos a ver como hacerlo...

En ./controllers/proyectosController.js, vamos a enviar 
por consola lo que el usuario escriba:

exports.nuevoProyecto = (req, res) => {
    // Enviar a la consola lo que el usuario escriba.
    console.log(req.body);
};

Esto se hace con req.body.

Es importante que sea request, por que bueno recuerda
request es la petición que tu haces, y en este caso 
es algo que nosotros estamos escribiendo, y .body es 
la forma en la que accedes a lo que va a imprimir esta 
página, lo que va a hacer parte de la respuesta.

Esto se lee en la consola pero la consola de la terminal

Cuando realizamos la prueba podemos ver que nos retorna:

user@DESKTOP-VI2L807 MINGW64 /c/proyectos/bootcamp-node-JuanPdelatorrevaldez/UpTaskNodeJS (master)
$ npm run start

> uptasknodejs@1.0.0 start
> nodemon ./index.js

[nodemon] 2.0.15
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,json
[nodemon] starting `node ./index.js`
undefined

Es decir nos devuelve undefined...

¿Y esto por que pasa?

Bueno para poder leer los datos de un formulario tienes que habilitar
una librería llamada bodyParser.

Por lo tanto vamos a abrir el archivo de configuración, que si recuerdas
dije que ibamos a estar volviendo mucho a este archivo, 
./index.js, y aquí vamos a habilitar body-parser, 
primero lo importamos (antes instanciar express):

Actualmente body-parser no se requiere instalar, anteriormente si.
Si tienes un proyecto muy anterior a express, sino te funciona lo más
seguro es que tengas que instalar la dependencia.

const bodyParser = require("body-parser");

// habilitar bodyParser para leer datos de un formulario
app.use(bodyParser.urlencoded({extended: true}));

lo que sigue
-------------
En el siguiente vídeo, veremos como hacer que este valor 
que ahora recuperarmos, sea parte de nuestro controlador, 
y acceder a el.

Asi que continuamos.

Validación Simple de un Formulario
------------------------------------
Veamos como validar que el usuario efectivamente agregó algo aquí 
en nuestro input.

Si yo por ejemplo ahora le doy click a agregar, sin poner nada,
puedes ver que en la terminal aparece nombre y aparece vacío.

user@DESKTOP-VI2L807 MINGW64 /c/proyectos/bootcamp-node-JuanPdelatorrevaldez/UpTaskNodeJS (master)
$ npm start

> uptasknodejs@1.0.0 start
> nodemon ./index.js

[nodemon] 2.0.15
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,json
[nodemon] starting `node ./index.js`
{ nombre: '' }

validando los errores
----------------------
Podemos acceder al nombre enviado utilizando destructuring - 
una nueva característica de ES soportada muy bien por Node, 
de la siguiente forma:

	const { nombre } = req.body;

Hay muchas formas de validar el nombre, existe un paquete 
llamado express valid editor...

Primero vamos a elaborar la validación como se dice a pie,
y más adelante los otros proyectos van a tener lo que viene
siendo, express validator.

./controllers/proyectosController.js
exports.nuevoProyecto = (req, res) => {
    // Enviar a la consola lo que el usuario escriba.
    // console.log(req.body);

    // Validamos que tengamos algo en el input
    const { nombre } = req.body;
    
    let errores = [];

    if (!nombre) {
        errores.push({"texto": "Agrega un Nombre al Proyecto"});
    }

    // si hay errores 
    if (errores.length > 0) {
        res.render("nuevo-proyecto", {
            nombrePagina: "Nuevo Proyecto",
            errores
        })
    }
};

./views/nuevo-proyecto.pug
extends layout 

block contenido
    .contenido-principal
        h1 #{nombrePagina}
        
        if errores 
            each error in errores 
                .alerta.error= error.texto

        form.agregar-proyecto(action="./nuevo-proyecto" method="POST")
            .campo
                label(for="nombre") Nombre Proyecto:
                input(type="text" id="nombre" name="nombre" placeholder="Nombre Proyecto")
            .campo.enviar
                input(type="submit" value="Agregar" class="boton")

Entonces si existe express validator, pero así es como haces validaciones
como se dice a pie, sin frameworks sin nada - bueno frameworks la parte
de express y node, pero con tu código en el controlador.

Esta es una forma de hacer una validación sin tener que agregar librerías.
Y obviamente los proyectos, los demás tendrán validacines con express validator 
para mostrarte <> formas. 

Esta es una.

lo que sigue
-------------
¿Qué pasa si NO hay errores?
Entonces tenemos que insertar en la BD.
Aún no hemos configurado ninguna BD, no hemos hecho todavía esta 
parte.

Así que a partir del próximo video veremos como instalar una BD
localmente.

Elije tu plataforma ya sea Windows o MAC, estará mostrando como 
instalar una BD local. 

Si ya tienes una instalada, te puedes saltar esos videos, 
no hay ningún problema.

Así que continuamos en el próximo video.

Instalando MySQL
------------------
Link:
	https://dev.mysql.com/downloads/windows/installer/5.7.html

Va a estar instalando la versión 5.7.xx de MySQL, por que si bien
la versión 5.8 es un poco más ligera, sin embargo la parte 
de autenticación de usuarios es un poco <>.

Entonces a veces marca errores cuando haces el deployment.

En el link hay 2 versiones, una es mucho más ligera que la otra.
La que nos interesa es la más pesada.

Una vez descargado, movemos el instalador al disco C:\.

Intente ver si te habre el wizard de MySQL, sino te abre, 
es muy recurrente este error - el instalador no hace nada.

Abrimos el cmd o la consola de powershell como Administrador y nos 
vemos hasta llegar al disco C:\, luego ahi escribimos 
el nombre del ejecutable y damos ENTER:

Windows PowerShell
Copyright (C) Microsoft Corporation. Todos los derechos reservados.

Prueba la nueva tecnología PowerShell multiplataforma https://aka.ms/pscore6

PS C:\WINDOWS\system32> cd ..
PS C:\WINDOWS> cd ..
PS C:\> .\mysql-installer-community-5.7.36.1.msi
PS C:\>

En este panel podemos elegir <> tipos de instalaciones, yo voy a
presionar en Custom, y le damos Next.

Aqui podemos elegir lo que vamos a instalar, en mi caso 
voy a instalar MySql Server:

	- MySQL Server 5.7.36 - X64

, y hago clic en la flecha derecha para pasarla al panel de la derecha.

Aqui en Application vamos a abrirlo, y aquí vienen, 
después de que viene MySQL Workbench, en mi caso vamos a utilizar 
TablePlus me gusta más. 

Y terminamos de abrir el Shell de MySQL (MySQL Shell):
	- MySQL Shell 8.0.27 - X64

Y puede ser que tenemos MySQL for Visual Studio.
Todo eso no lo requerimos.

Los conectores tampoco.

Entonces con estos 2:
	- MySQL Server 5.7.36 - X64
	- MySQL Shell 8.0.27 - X64

es suficiente, le podemos dar Next.

Entonces puedes ver que nos dice que está lista para instalar, 
así que le damos ejecutar.

configurar MySQL
-----------------
Vamos a configurar lo que es MySQL.

En High Availability elegir:
	- Standlone My SQL Server / Classic My SQL Replication

En Type and Networking nos pregunta que tipo de configuración
va a ser, va a ser un Servidor de Desarrollo - Development
Computer.

En Account and Roles, el usuario que viene por default es 
el root, aquí le puedes definir cual va a ser el password.

En MySQL User Accounts, puedes agregar algún usuario 
- yo personalmente lo dejo siempre como root, 
porque luego tiendo a que se me olvidan los usuarios que voy creando.

Dice que nuestro servicio se llama:
	- MySQL57

En Start the MySQL Server at System Startup, nos permite tener disponible nuestro 
servidor MySQL apenas inicia Windows, más o menos el servidor consumos unos 150/200 mb,
así que dependiendo de la computadora que tengas, y si vas a desarrollar mucho, pues 
puede ser que lo quieras.

Si es un poco con menos memoria, pues probablemente quieras arrancar todo el servicio.

Les dejamos los defaults y le damos Next, y luego a Execute, y va a hacer las últimas
ejecuciones, asi que esperamos un poco.

Entonces puedes ver que dice:
	- The configuration for MySQL Server 5.7.36 was successful. 
	  Click Finish to continue.
	  (la configuración se completó correctamente)

Damos click en Finish y luego en Next.

Entonces puedes ver que nos dice:
	- Start MySQL Shell after setup 	

si queremos iniciar MySQL una vez haya finalizado, y le vamos a dar Finish.

Ahora en caso de que por ejemplo, le hayas dado que no arranque el servicio
de MySQL, entonces lo vas a arrancar tu.

Tienes que escribir sobre la busqueda en Windows: 
	- Servicios 
	(es muy importante darle botón derecho y ejecutarlo como administrador,
	 por que hace un cambio importante, entonces requieres los permisos
	 adecuados para hacerlo).

Y aquí vas a buscar:
	- MySQL57

Entonces le das botón derecho y en Iniciar, vas a iniciar el servidor.

De esa forma lo vas a iniciar tu manualmente.

Si le diste que arranque un vez que encienda la computadora, no 
tienes que hacer nada más.

Este es el Shell de MYSQL, lo voy a cerrar y vamos a abrirlo 
por ejemplo en PowerShell:

Windows PowerShell
Copyright (C) Microsoft Corporation. Todos los derechos reservados.

Prueba la nueva tecnología PowerShell multiplataforma https://aka.ms/pscore6

PS C:\WINDOWS\system32> mysql -u root -p
Enter password: ****
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 8
Server version: 5.7.36-log MySQL Community Server (GPL)

Copyright (c) 2000, 2021, Oracle and/or its affiliates.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql> SHOW DATABASES;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
4 rows in set (0.00 sec)

mysql>

Con SHOW DATABASES; 

mostramos la BD's que ya están creadas, por defecto tenemos: 
	- information_schema
	- mysql
	- perfomance_schema
	- sys

Si lo tenías instalado anteriormente, probablemente te mostrará más 
BD's.

Entonces con eso ya tenemos listo la instalación de MySQL.

lo que sigue
-------------
En el siguiente video vamos a instalar una herramienta que me gusta
mucho para ver nuestras BD's de forma más visual, que se llama
Table Plus.

Instalando TablePlus
----------------------
Link:
	https://tableplus.com/

Necesitamos una herramienta para verificar que las operaciones que hacemos sobre la BD 
se van realizando de forma correcta.

Podríamos hacerlo directamente en el Shell de MySQL, pero sin duda,
si vas a dedicarte de forma más profesional, lo ideal es tener un visor, digamos,
más gráfico para no perder mucho tiempo.

Uno que me gusta mucho es TablePlus. 

Para MySQL existen otras opciones, por ejemplo: MySQL WordBench, pero me parece que TablePlus 
es una excelente opción.

Es gratis, con ciertas limitaciones:
	- Solamente te permite abrir 2 tabs o 2 ventanas, 
	  pero si quieres abrir más requieres pagar.

Para completar el curso, me parece una excelente opción.

Que es un ORM
------------------
En este video vamos a ver que es un ORM.
Estaremos utilizando un ORM para cada proyecto, así que es buena 
idea saber qué son y cómo nos vamos a beneficiar de ellos.

Que es un ORM - Object Relational Mapping
Un ORM te permite almacenar / leer objetos en tu base de datos muy facilmente:

- Los objetos se definen con un lenguaje de programación 
    - En nuestro caso se define con JavaScript.
    - Se crea un archivo que se conoce como modelo, 
      y en el se definen la forma que van a tener estos datos.
      Es decir, tu puedes crear o en tu aplicación tal vez es uno de manejo
      de clientes, y es el en el ORM donde le das la forma a los objetos de cliente,
      es decir un ID, con un Nombre, con un Apellido, con un nombre de empresa, o un 
      teléfono de contacto.
  Todo eso se define en el objeto del ORM, y se define con un lenguaje de programación

- Relational es la Base de Datos.
     Relational al final es lo que es la BD, entonces es donde se almacenan los objetos.

- Mapping es la unión de ambos en tus aplicaciones web.
     Esta unión es la que me permite que con código del lenguaje de programación
     que estoy utilizando pueda realizar consultas a la BD, unir los objetos
     con el relational, y utilizar esos datos y mostrarlos en mi aplicación.

Ventaja del ORM
----------------
Evita la repetición de código ya que el modelo solo se define en un lugar, y solo con 
importar el modelo al contralador, tendrás acceso a todos los métodos del ORM.
Por ejemplo: para crear un nuevo cliente, eliminarlo, o actualizarlo, etc.

Acelera el proceso de desarrollo, ya que hay una gran cantidad de métodos 
para el CRUD (Crear, Leer, Actualizar, Eliminar) 
  - que casi todos los proyectos hoy en día lo requieren


No es necesario escribir código SQL.
  - Todos los métodos por ejemplo para crear un registro ya existen en el ORM,
    incluso para relacionar una tabla con otra, todo eso ya existe y 
    lo veremos en detalle en el curso

Seguridad
   - Los ORM cuenta con sentencias preparadas para evitar la inyección de datos no esperados, 
     y cuentan con una gran cantidad de medidas de seguridad que hacen que no tengas que 
     preocuparte por esto en tus aplicaciones.

Escrito en el lenguaje de tu aplicación web.
   - Por ejemplo a <> de SQL, si estas acostumbrado a escribir algo de código SQL,
     puedes llegar a realizar consultas muy complicadas, que tal vez no tengamos
     conocimientos de cómo hacerlas ... el ORM se encarga de esa parte.

   - Entonces no necesitas escribir código SQL, el ORM tiene una 
	 serie de métodos que están escritos en el lenguaje de tu aplicación

Desventajas del ORM
--------------------
  - Aprender la sintaxis nueva del ORM
     - Uno de los detalles que veo mucho, es que cuando alguien utiliza 
       un ORM, comienza a escribir código SQL donde se acuerda como es el 
       SQL si es muy sencillo un SELECT lo hacen, y por ejemplo si es muy
       complicada la consulta, deciden utilizar el ORM.

       Eso no se recomienda, siempre hay que utilizar los métodos que nos provee
       el ORM.

	   Esto llega a ser un poco cansado estar viendo los ejemplos, 
       la documentación, y encontrar las funciones que hacen lo que necesitamos.

  - Instalarlo (en algunos casos es sencillo, y en otros no tanto)
     - A veces por ejemplo instalarlo localmente llega a ser un problema,
       instalarlo en un servidor, llega a ser incluso muy complicado.

     - Afortunadamente node lo hace muy sencillo, gracias a npm

  - El performance puede ser un poco más lento que consultas SQL nativas
     - Un ORM es una capa de abstracción sobre la BD, es decir si tu utilizas un método
       para crear un registro, el ORM se encarga de escribir el código SQL, pero tu 
       estás escribiendo el código en el lenguaje de programación.

       Por lo tanto en lo que se interpreta lo que estás haciendo y se ejecuta ese SQL,
       puede llegar a ser un poco más ento, que si estuvieras escribiendo las consultas nativas
       con código SQL.

       Nada va a ser más rápido que una consulta nativa. El ORM va a ser un poco más lento, pero 
       te va a permitir que no tengas que aprender mucho SQL, o si no quieres aprenderlo o simplemente
       tienes mucha prisa en este proyecto, te va a salvar mucho tiempo 

Algo muy importante es que: 
   Un ORM no especifico de Node.

Muchos lenguajes de programación tienen un ORM: 
	- PHP: Propel y Doctrine
	- Java = Hibernate
	- Python = SQL Alchemy
	- Django = tiene su propio ORM interno
	- C# = Entity Framework       

Y en realidad en muchos lenguajas vas a encontrar un ORM.
Es una herramienta muy común que ahorra bastante tiempo.

ORM's en Node
--------------
En cuanto a Node existen 2 opciones muy claras en cuanto a ORM's:
   - Sequelize: soporta MySQL, PostgreSQL, SQL Server y SQL Lite en tus aplicacaciones Node.
   - Mongoose: es otro ORM que te permite conectar MongoDB con tus aplicaciones Node

Osea ya sea que decidas que tu aplicación debe utilizar una BD relacional
o no relacional, sequelize y mongoose tienen cubierta esta parte.

Modelo y ORM
-------------
Algo muy importante que muchas veces la palabra Modelo y ORM
se pueden confundir un poco.

Y esto pasa porque usualmente los modelos y el ORM están muy relacionados
y puede ser posible que sea dificil de comprender que es lo que hace c/u.

El modelo es un lugar único donde se describe la forma de los
objetos y es fácil agregar / quitar campos para la BD.

Mientras que el ORM tiene los métodos para la BD. 

Mientras que el Modelo describe, por ejemplo la tabla de productos,
que tiene un Id, que tiene por ejemplo un nombre, que tiene un 
varchar de 60 caracteres el nombre, que tiene un código, que
tiene un precio, que tipo de dato va a ser. 

Toda esa parte se define en el modelo.

Por otro lado el ORM cuenta con todos los método para crear 
nuevos productos, para eliminarlos, actualizarlos, para
realacionar productos con una categoría, para relacionar
productos con un cliente, etc. 

Entonces espero que haya quedado un poco más clara esa parte, 
sino aquí tenemos un ejemplo.

Ejemplo
--------
Modelo
-------
const Usuarios = db.define {
    "usuarios",
    {
        id: {
            type: Sequelize.INTEGER,
            primaryKey: true,
            autoIncrement: true
        },
        password: {
            type: Sequelize.STRING,
        }
        nombre: {
            type: Sequelize.STRING,
        },
    }
};

Supongamos que tenemos un modelo de usuario, en este caso, 
nota como estoy utilizando Sequelize para definir el tipo.

Es por eso que puede ser un poco complejo la <> entre modelo y ORM.
Pero nota como defino la estructura de modelos utilizando un lenguaje
de programación en lugar de utilizar SQL, utilizo el lenguaje
de programación que tengo en mi aplicación.

Por otro lado tengo el ORM, pero algo importante, 
nota como el modelo de estructura tenemos un Id,
tenemos un password, y tenemos un nombre ...
Faltaría un correo y muchos otros campos, que no cabian
en este lugar.

Ahora si vamos con la parte del ORM.

Supongamos que quieres crear un usuario puedes ver la sintaxis:

CREAR USUARIO:

const usuario = {
   password,
   nombre
};

Usuarios.create(usuario);

Nota como este usuario que esta aquí, es el mismo nombre del modelo
Usuarios; entonces de esa forma sabe en que partes se tienen que insertar
los datos.

Luego utilizamos .create() le pasamos el objeto de usuario, y eso hace
que se inyecte, que se agregue en lo que viene siendo la BD.

Así de sencillo es crear un nuevo registro utiliando un ORM.

Este ejemplo utiliza Sequelize, pero con Mongoose es muy similar.

Algo importante no escribes por ejemplo, INSERT INTO y después colocas los valores.

Nada de eso se hace en esta parte, el ORM se encarga de todo.

Y por ejemplo para obtener un usuario:

Usuario.findOne({
   where: {
      email
   }
});

En este caso estamos utilizando uno de los métodos del ORM.

Entonces la <> aquí, lo que quiero que te lleves:
   - El modelo da la estructura de los datos
   - El ORM nos da todos los métodos para trabajar o consultar la BD

Estas son cosas que no se aprenden como una diapositiva, por eso 
yo recomiendo que veas lo que vien siendo el primer proyecto, 
lo finalizes, y de ahí vuelvas a ver este vídeo.

Seguramente toda va a quedar mucho más claro.

De nueva cuenta los ORMs utilizados en este curso van a ser:
 - Sequelize en 2 proyectos, 
 - y también Mongoose

Instalando y Configurando Sequelize
--------------------------------------
En nuestro proyecto actualmente lo único que nos hace falta, puedes ver que tenemos
pero nos falta mucho, pero de la parte del MVC del Model View Controller ya tenemos,
el Controller y las Vistas.

Entonces falta la parte de los modelos.

Usualmente los modelos es esa capa que interactúa directamente con la BD.
Por lo tanto vamos a abrir el Chrome en:

http://docs.sequelizejs.com

https://sequelize.org/v4/

Estaremos utilizando una herramienta llamada Sequelize.

Sequelize soporta bases de datos: 
  - PostgreSQL
  - MySQL
  - SQL Lite
  - MSSQL

Estaremos utilizando también Sequelize en un proyecto que viene más adelante con PostgreSQL,
y estaremos creando otro proyecto con Mongo DB, que también tiene un ORM llamado Mongoose.

¿Cuál es la ventaja de utilizar Sequelize?
Por ejemplo donde tenemos aquí en Querying damos click:

https://sequelize.org/v4/manual/tutorial/querying.html

Puedes ver que para obtener todos los registros de la BD solamente se utilizan
estos métodos:

Model.findAll({
  attributes: ['foo', 'bar']
});

Lo cual viene a reemplazar a una consulta SELECT.

También tienen esta parte de los modelos:

https://sequelize.org/v4/manual/tutorial/models-usage.html

Los modelos van a describir como funciona tu base de datos.
Es decir si tienes por ejemplo en el proyecto que estamos haciendo, 
aquí un nuevo proyecto.

Supongamos que creas una nueva tabla en tu base de datos para almacenar
los proyectos, tienes un Id, el nombre del proyecto, y en nuetro caso estaremos
almacenando la URL - te voy a explicar por qué un poco más adelante.

Esa parte de todas las tablas y las columnas es que se conoce como modelos.

En ellos vas a definir cómo se llama la tabla, qué campos contiene, 
y qué tipos son.

Vamos a empezar este proyecto, aquí en terminal, voy a detener el servidor de Node.
Vamos a instalar un par de dependencias.
mysql2 es una dependencia de node, y también vamos a instalar sequelize, ambas 
son dependencias no del desarrollo, porque tienen  que ir con el servidor, o tienen que ser
parte del deployement (dependencias del proyecto):

npm install --save mysql2 sequelize

================================================================================
========================= NOTA IMPORTANTE ======================================
================================================================================
El curso esta realizado las siguientes versiones de mysql2 y sequelize.

mysql2 --> 1.6.4

sequelize --> 4.42.0

Para mas info ver el package.json del proyecto final en el repositorio del autor:
https://github.com/juanpablogdl/uptasknode/blob/master/package.json


Entonces vamos a ejecutar el siguiente comando npm para obtener estas versiones
específicas, siguiendo la siguiente sintaxis:

npm install --save <package>@<version>

npm install --save mysql2@1.6.4

npm install --save sequelize@4.42.0

================================================================================
========================= CONTINUEMOS ... ======================================
================================================================================

El siguiente paso es crear la configuración de sequelize.

Damos clic aquí en la primera opción, por que aquí nos viene el archivo de configuración:

https://sequelize.org/v4/manual/installation/getting-started#setting-up-a-connection

Vamos a volver a nuestro proyecto, y aquí voy a crear una nueva carpeta 
- en la raíz del proyecto, que voy a llamar config (ahi voy a crear
toda la configuración), y luego un archivo llamado db.js.

uptasknode
  -- config
     -- db.js

Archivo ./config/db.js
const Sequelize = require('sequelize');
const sequelize = new Sequelize('uptasknode', 'root', 'root', {
  host: '127.0.0.1',
  dialect: 'mysql',
  port: '3306',
  operatorsAliases: false,
  define: {
    timestamps: false 
  },
  pool: {
    max: 5,
    min: 0,
    acquire: 30000,
    idle: 10000
  }
});

Y este es el archivo de configuración, así es como conectas 
Node con una BD de MySQL.

lo que sigue
-------------
En el siguiente video veamos como definir los modelos. 
Vamos a crear el modelo de proyectos, así que continamos en
el próximo video.

Creando el modelo de Proyectos
--------------------------------
En este vídeo vamos a craer un modelo que va a ser el de los proyectos, por lo tanto
vamos a crear dentro la raíz del proyecto una nueva carpeta llamada models:

uptasknode
  -- models

Ahora si tenemos el Model, View, Contoller listo!

Usualmente los modelos siempre se nombre con mayúsucla la primera letra, 
por lo tanto aquí ponemos Proyectos.js:

uptasknode
  -- models
     -- Proyectos.js

Y usualmente es en el modelo donde vas a colocar toda la descripción de los campos de tu BD.

Vamos a encontrar buena información aquí en Model definition, ahorita lo vemos:
https://sequelize.org/v4/manual/tutorial/models-definition.html

Archivo ./models/Proyectos.js:
const Sequelize = require("sequelize");

const db = require("../config/db");

const Proyectos = db.define('proyectos', {
    id: {
        type: Sequelize.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    nombre: Sequelize.STRING,
    url: Sequelize.STRING
});

module.exports = Proyectos;

Como puedes ver la última línea de Proyectos.js es:
module.exports = Proyectos;

Con esta línea hacemos que todo el código que esta en Proyectos.js,
se pueda importar en otras piezas de nuestro proyecto.

Tenemos por ejemplo utilizando este modelo aquí en la parte princinpal
(./index.js), y también en los controladores para hacer consultas a las
BD, y pasar los resultados hacia las vistas.

lo que sigue
-------------
Con eso esta listo este modelo ... lo vamos a probar tanto el modelo, 
como la conexión en el siguiente vídeo.

Permitiendo que Sequelize Genere las Tablas Automáticamente
--------------------------------------------------------------
En este vídeo vamos a probar nuestra conexión hacia el servidor de MySQL.

Por lo tanto vamos a abrir el index.js (./), y vamos a insertar la siguiente línea 
- antes o después de se crea express, ya que no require lo que viene siendo express:

// Crear la conexión a la BD
const db = require ("./config/db");

Este db va a contener <> métodos, si le pones db punto, aquí te aparece una serie de métodos, 
de los cuales vamos a usar autenticate():

db.autenticate();

Esto nos va a retornar un Promise, quiero mostrarte algo ...

Si abres la página principal de sequelize:

https://sequelize.org/v4/

Puedes ver que aqui dice que Sequelize es un ORM basado en Promises:

Sequelize is a promise-based ORM for Node.js  ...

Por lo tanto accedes a los resultados con .then(), y esto va a correr una arrow function, y aquí podemos 
correr un console.log con un mensaje avisando que se conecto a la BD;
y caso contrario caería en un catch (error también es una arrow function, 
pero como tiene un solo parámetro prescindimos de los paréntesis):

db.authenticate()
    .then(() => console.log("Conectado al Servidor"))
    .catch(error => console.log(error))

Nos conectamos al nuestro servidor de MySql con TablePlus y ejecutamos
la siguiente instrucción SQL:

create DATABASE uptasknode;

En archivo ./config/db.js, al final del mismo realizamos el module.exports:
const Sequelize = require('sequelize');
const db = new Sequelize('uptasknode', 'root', 'root', {
  host: '127.0.0.1',
  dialect: 'mysql',
  port: '3306',
  operatorsAliases: false,
  define: {
    timestamps: false 
  },
  pool: {
    max: 5,
    min: 0,
    acquire: 30000,
    idle: 10000
  }
});

module.exports = db;

Si ahora corremos nuestro proyecto:
foliva@ARRMRLAP005 MINGW64 /c/proyectos/bootcamp-node-JuanPdelatorrevaldez/UpTaskNodeJS (master)
$ npm run start

> uptasknodejs@1.0.0 start
> nodemon ./index.js

[nodemon] 2.0.15
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,json
[nodemon] starting `node ./index.js`
Executing (default): SELECT 1+1 AS result
Conectado al Servidor

Listo! Ya estamos conectado a nuestro servidor de BD MySQL!

================================================================================
========================= NOTA IMPORTANTE ======================================
================================================================================
En este momento del video el autor comenta lo siguiente:
Una vez que guardas cambios, puedes ver que nos aparece este mensaje:

code: 'ER_NOT_SUPPORTED_AUTH_MODE',
eerno: 1251,
sqlState: '08004',
sqlMessage: 
 'Client does not support authentication protocol requested by server; considerer upgrading MySQL client' 

y sigue comentando:
si recuerdas casi al inicio cuando instalamos MySQL, nos preguntaba si queríamos
utilizar el nuevo método de encriptación o el anterior.

Yo cuando estuve instalandolo para hacer pruebas, y me decía que anterior, 
bueno lo seleccionaba y me volvió a preguntar, y me volvió a preguntar,
hasta que seleccioné el nuevo y me dejó ya continuar la instalación. 

En este caso puedes ver como que el nuevo no funciona aún.

Vamos a abrir una nueva terminal y vamos a escribir:
mysql -u root -p 
Enter password: ****

En el gis que comparti anteriormente venía esta pieza de código:
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysq_native_password BY 'password';
FLUSH PRIVILEGES;

Luego de ejecutado este código en el consola, detenemos la aplicación 
y volvemos a ejecutarla.

Y vas a ver que nos va a devolver:

code: 'ER_BAD_DB_ERROR',
eerno: 1049,
sqlState: '42000',
sqlMessage: 
 "Unknown database 'uptasknode'" 

Es decir base de datos desconocida.
Ahora entonces vamos a Table Plus y creamos la base de datos uptasknode.

Detenemos el servidor de la aplicación, y lo ejecutamos de nuevamente.

Puedes ver que dice conectado al servidor:

Executing (default): SELECT 1+1 AS result
Conectado al Servidor


================================================================================
========================= CONTINUEMOS ... ======================================
================================================================================
Eso usualmente esta mucho mejor, ya creamos la base de datos ...
Pero puedes ver que si abro mi modelo en el archivo
./models/Proyectos.js, puedes ver que le dice cierta estructura,
un Id, un nombre, una URL. 

Entonces podemos utilizar Sequelize para que cree esa estructura de la BD
muy fácilmente.

Vamos abrir el ./index.js, y en lugar de tener 
authenticate(), que solamente se va a conectar al servidor,
podemos utilizar .sync().

db.sync()
    .then(() => console.log("Conectado al Servidor"))
    .catch(error => console.log(error))

Algo muy importante, tienes que importar primero el modelo, 
para que sepa que va a crear.

// Importar el modelo 
require("./models/Proyectos");

Archivo ./index.js
// import express from "express"; // no soportada por express por DEFAULT
const express = require("express");
const routes = require("./routes");
const path = require("path");
const bodyParser = require("body-parser");

// Crear la conexión a la BD
const db = require ("./config/db");

// Importar el modelo 
require("./models/Proyectos");

db.sync()
    .then(() => console.log("Conectado al Servidor"))
    .catch(error => console.log(error))

// crear un app de express
const app = express();

// Donde cargar los archivos estáticos
app.use(express.static("public"));

// Habilitar pug
app.set("view engine", "pug");

// Añadir la carpeta de las vistas
app.set("views", path.join(__dirname, "./views"));

// habilitar bodyParser para leer datos de un formulario
app.use(bodyParser.urlencoded({extended: true}));

app.use("/", routes());

app.listen(3000);

Si paramos y ejecutamos nuevamente la aplicación desde la terminal podemos ver:
foliva@ARRMRLAP005 MINGW64 /c/proyectos/bootcamp-node-JuanPdelatorrevaldez/UpTaskNodeJS (master)
$ npm run start

> uptasknodejs@1.0.0 start
> nodemon ./index.js

[nodemon] 2.0.15
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,json
[nodemon] starting `node ./index.js`
Executing (default): CREATE TABLE IF NOT EXISTS `proyectos` (`id` INTEGER auto_increment , `nombre` VARCHAR(255), `url` VARCHAR(255), PRIMARY KEY (`id`)) ENGINE=InnoDB;
Executing (default): SHOW INDEX FROM `proyectos`
Conectado al Servidor

Podemos ver que dice que crea la tabla proyectos, en caso de que no exista con un Id, y con toda
la estructura que le hemos dado:

  - viene el nombre: le di un VARCHAR de 255 ( no hay ningún problema )
  - url: VARCHAR de 255
  - y un PK: que lo pone al Id, etc.

Si abrimos de nueva cuenta el Table Plus, por ejemplo aquí vamos a seleccionar
la BD uptasknode, damos Open.

Y puedes ver que aquí viene la tabla proyectos, la cual esta vacía, aún 
no hemos agregado nada, pero tenemos el Id, el nombre, y la url.

Por lo tanto Sequelize por si solo, puedes definir tu modelo.

Archivo ./models/Proyectos.js
const Sequelize = require("sequelize");

const db = require("../config/db");

const Proyectos = db.define('proyectos', {
    id: {
        type: Sequelize.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    nombre: Sequelize.STRING,
    url: Sequelize.STRING
});

module.exports = Proyectos;

Y con este método de .sync():
// Importar el modelo 
require("./models/Proyectos");

db.sync()
    .then(() => console.log("Conectado al Servidor"))
    .catch(error => console.log(error))

Te va a crear toda la estructura!

lo que sigue
-------------
Estaremos volviendo a esta parte un poco más adelante, pero 
ya tenemos nuestra BD conectada con todo listo

El siguiente paso es volver a la aplicación y ver como vamos a 
insertar los registros en la BD.