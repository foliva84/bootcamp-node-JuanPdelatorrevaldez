choco install nodejs.install

uptasknode

https://github.com/juanpablogdl/uptasknode

Dependencias
-------------
Cuando instalas una dependencia crea la carpeta node_modules

Dep. del Proyecto: npm install --save express   -- se guardan en package.json
     Express-> es una dep. de proyecto, por que nuestro proyecto va a estar montado en express,
	           incluso cuando hagamos el deployment en el servidor.
			npm install --save express
	
		Una dep. de proyecto va a acompañar al proyecto desde que lo estoy creando hasta 
		el deployment.
Dep. de desarrollo: existen otras dependencias que solo son necesarias en la etapa de desarrollo. 
     nodemon: nos va ayudar por ejemplo cuando estemos haciendo cambios en los <> archivos, 
	          nodemon va a detectar esos cambios, va a reiniciar el servidor y nos va a mostrar
			  los ultimos cambios.
			  De esa forma podemos estar escribiendo código, agregar más funciones e ir probando mucho 
			  más rápido.
		npm install --save-dev nodemon
	    ¿Por qué esta es una dependencia de desarrollo?
		Por que los cambios en el código, únicamente se van a hacer en la etapa de desarrollo,
		NO se van a hacer en el servidor, por lo tanto termina siendo una dependencia de desarrollo,
		que no va a estar cuando hagamos el deployment, no va a ser parte del proyecto, solamente
		del desarrollo.

		Una dep. de desarrollo entonces solamente van a estar disponibles en la etapa de desarrollo.

Creando el servidor de Express
-------------------------------
Archivo package-lock.json
--------------------------
Es igual al package.json contiene como están relacionadas las dependencias de las dependencias.
Es decir, express tiene dependencias, y nodemon también.

Utilizando npm install
--------------------------
Si eliminamos la carpeta node_modules, y el archivo package-lock.json, y solo dejamos el package.json,
puedo reconstruir las dependencias en la terminal, de la sig. manera:

npm install

escribamos código: creamos un nuevo archivo en la raíz llamado index.js, el cual va a servir para la configuración
-----------------
del proyecto, en el voy a colocar mi aplicación de express, voy a estar agregando algunas dependencias, y muchas otras cosas.
Este archivo, lo estaremos visitando a menudo a lo largo del curso. 

importamos express
------------------
Podemos utilizar la sintaxis ES6 para importar express:
import express from "express";

Esta es la sintaxis nueva para importar, sin embargo, NO es soportada por default,
la puedes habilitar, pero NO por default. 
En express se utiliza algo utilizado require:

const express = require("express"); 

Esto: 
		import express from "express";

y esto: 
		const express = require("express"); 

!Son lo mismo!

Pero express soporta la sintaxis con el require.

creamos la app express
-----------------------
const express = require("express"); 

const app = express(); // uso express como función

la varible app va a contener todo lo necesario por parte de express para crear el servidor.

setear puerto de express
-----------------------
También le podemos decir en que puerto corre express utilizando la función liste() y el número de puerto:

app.listen(3000);

El puerto puede ser cualquiera, solamente nos debemos asegurar que no este ocupado.
Por ej.: si tienes MySql y esta en el puerto 80, y pones el mismo, lo más seguro es que no arranque.
Por lo tanto un puerto seguro es 3000, otras personas le ponen 7000 o 9000 o cualquier número de ese
tipo va a funcionar correctamente. 

arrancar el servidor express
---------------------------
Puedes ver que tenemos ya este servidor, pero tenemos que arrancar el servidor de express.
Para ello en este package.json es que tenemos estos "scripts", y en ellos puedes colocar
o puede conectar lo que tengas en este index.js o en tu proyecto de express con el 
package.json. 
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },

Puedes crear tu propio script, éste es uno de "test", yo usualmente siempre lo borro.
Y voy a crear uno que se llame "start". Muchas personas le ponen "watch", otras 
personas le ponen "dev", puedes nombrarlo como tu desees.
En mi caso le voy a poner "start" para que arranque el servidor, y aquí le pones que 
instrucción va a correr.  
Ahora si recuerdas, mencioné anteriormente que instalabamos nodemon para que detecté 
todos los cambios, cada que yo haga un cambio por ejemplo en una vista, en un controlador,
etc, se reinicia el servidor y me muestra los últimos cambios. 

Por lo tanto vamos a decir que, queremos utilizar nodemon, y debido a que sabe donde esta
almacenado (aquí en node_modules, vas a encontrar una carpeta nodemon también), y después 
le decimos cual va a hacer el punto de arranque, donde va a encontrar la configuración, y 
debido a que estamos en el package.json, y el index.js esta en el mismo nivel, solamente
le ponemos ./index.js:

  "scripts": {
    "start": "nodemon ./index.js"
  },

Va a buscar aquí (./index.js") la configuración, una vez que yo corra el script. 
Si corres estos scripts utilizando npm de tu package.json, si buscas por ejemplo algún 
ejemplo ya hecho de node, lo más seguro es que tengas muchos más scripts, que estaremos
viendolos más adelante con más detalle.

En la terminal ponemos npm que es el comando, luego run y el nombre del script, en nuestro
caso start:
	npm run start 

Ahora start es como que, es muy común, demasiado común que también va a funcionar si le pones nada más:
	npm start
	
Ejemplo:

user@DESKTOP-VI2L807 MINGW64 /c/proyectos/bootcamp-node/UpTaskNodeJS
$ npm start

> uptasknodejs@1.0.0 start
> nodemon ./index.js

[nodemon] 2.0.15
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,json
[nodemon] starting `node ./index.js`

Puedes ver que me dice aquí que ha comenzado el servidor de node, si recuerdas le 
dimos que tiene que escuchar en el puerto 3000. 
Accedes a tu proyecto de node poniendo en un navegador:

http://localhost:3000/ 

Puedes ver:
	Cannot GET /
que nos dice que no puede obtener la ruta diagonal.

Pero no hay ningún problema, eso quiere decir que se ha creado el servidor de express.

Es mucho más sencillo, puedes ver que son nada más que 3 líneas para configurar un servidor
de express.

Si lo crearamos todo nosotros sería mucho más código, y no le veo sentido en realidad. 
Sería código que nunca utilizarías en tu vida. 


configurando una ruta para el home
Aquí le vamos a decir, o aquí vamos a configurar que se va a ver cuando 
yo entro en lo que viene siendo esta página, cuando yo abro:

http://localhost:3000/

Para ello defines algo que se llama "rutas", una ruta para la home.

Aquí voy a usar use() que es lo que se conoce como el middleware 
de express. 

Piensa en el middleware en funciones que se ejecutan una tras otra.
Más adelante estaremos viendolo más a detalle.

	app.use("/", (req, res) => {
		res.send("Hola");
	});

Básicos del Router
-------------------------------
En el vídeo anterior configuramos ya lo que viene siendo el servidor
de express, tenemos una parte que es configuración de express, y tenemos
una ruta hacia la home.

	app.use("/", (req, res) => {
		res.send("Hola");
	});

Y utilizamos este .use() y este .send(), y tal vez tengas dudas de que son.
Todo esto es parte de lo que viene siendo por así decirlo parte del lenguaje, 
de express.
Que son funciones que existen en express, y por ejemplo .use(), esto lo que 
hace es que, cualquier request, hay muchos request en HTTP, están los de POST,
están los de GET, están los de PATCH, los de DELETE, etc; cualquier request
va a correr este código, cuando tienes .use() cualquiera de todos los request, 
corre este código. 

Puedes ponerle aquí .get(), y solamente cuando tengamos el request de GET,
va a imprimir Hola.

	app.get("/", (req, res) => {
		res.send("Hola");
	});

Pero por ejemplo si tuvieramos un formulario aquí, con el método de POST, 
y yo enviará datos al formulario éste no correría por que utilizaría .get() 
- éste es el código anterior. 
Pero si lo pones como .use() va a leer tanto GET como POST, y cualquier 
otro verbo de HTTP. 

Para este punto .send() lo que imprime es solamente esto ( Hola ).
Supongamos que estas creando una REST API y realizas una consulta a una BD - 
que es algo que veremos mucho más adelante, y supongamos que tenemos
un arreglo de productos (que es lo que te devolvería una consulta a una BD):

const productos = [
	{ 
		producto: "Libro",
		precio: 40
	},
	{ 
		producto: "Computadora",
		precio: 10000
	}	
];

y ahora send() envia ese array:

	app.get("/", (req, res) => {
		res.send(productos);
	});

Imprime o nos da una respuesta como una arreglo:
[{"producto":"Libro","precio":40},{"producto":"Computadora","precio":10000}]

Pero también puedes en una REST API se recomienda utilizar .json():

	app.get("/", (req, res) => {
		res.json(productos);
	});

y eso te va devolver la respuesta como JSON.

¿Cuál es la ventaja de este JSON? Qué lo puedes consumir en otro proyecto
de Angular, o de VUE, o de React, o cualquier otro.

Puedes acceder a datos desde otra aplicación, y eso es lo que hace esta parte 
de aquí - res.json(productos), es como se van a mostrar los datos.

send() es la respuesta más básica, 
y json() más adelante veremos como mostrar HTML, 
y para ello se utiliza .render()

El primer proyecto esta pensado para utilizar como vista, por eso 
el .render() se utiliza para las vistas, un motor que se llama pug

Espero haya quedado más claro el uso del .use() y el uso del .send().

Lo que viene siendo el request y el response, lo veremos más a detalle 
conforme vayamos avanzando.

Solamente ten en cuenta esto, request es la consulta que tu haces 
cuando le das por ejemplo ENTER, o realizas una inserción de un 
formulario. Eso viene siendo el request.

El response es que te devuelve el servidor, en base a lo que tu hiciste
request.

Por ejemplo si yo hablo la página principal, la respuesta del servidor es ponerme
un Hola, y aquí esta, es parte de la respuesta.

En el siguiente vídeo vamos a continuar trabajando, la idea es comenzar a crear
el proyecto desde ya, tampoco vamos a perder el tiempo, en una introducción
de 100 vídeos, y 5 vídeos de proyecto, no es mi tipo de enseñanza.

En el sig. video vamos a comenzar a crear lo que viene siendo la estructura 
de este proyecto.

Creando un Archivo de Rutas
-------------------------------------------
intro
------
Actualmente nuestro proyecto solamente cuenta con una sola ruta, 
lo más seguro es que si estás creando por ej, un sitio web o una
aplicación tengas <> rutas.

Un ejemplo muy sencillo podría ser:

app.use("/nosotros", (req, res) => {
    res.send("Hola");
});

/nosotros, /contactos, /blog, etc, sería muchas rutas las que
tendría tu sitio web.

El detalle de hacer algo así o en este archivo (./index.js), 
es que puedes ver que nada más tenemos uno (un solo archivo .js),
es que este archivo muy pronto estará muy desordenado, tendrías
mucho código, que bien podría ir en otro archivo.

Y para eso tenemos que crear <> carpetas.
Usualmente todo lo que son las rutas, se recomienda tenerlo
en una carpeta llamada /routes, y aquí dentro voy a poner un 
index.js (./routes/index.js).

Siempre se recomienda tener esa seperación, por eso también 
vamos a utilizar Model View Controller - MVC, para etner esa separación,
lo que se conoce como separación de responsabilidad, donde c/parte 
de la aplicación hace algo. 

Para poder definir estas rutas la sintaxis va a hacer un poco diferente,
por que si nada más cortas y lo pegas aquí, no va a funcionar de la misma 
forma (el contenido de lo que tenemos en ./index.js):

	// ruta para el home 
	app.use("/", (req, res) => {
		res.send("Hola");
	});

	app.use("/nosotros", (req, res) => {
		res.send("Hola");
	});

Por ejemplo aquí puedes ver que dice app.use(), pero este app no esta 
dispnible en este archivo, y NO podemos crear otra INSTANCIA de express.

usar express router
-------------------
Por lo tanto para ello se utiliza algo que se conoce como Express router,
entonces al principio de index.js (./routes/index.js) vamos a escribir:

const express = require("express");
const router = express.Router();

exportar express router
------------------------
Tenemos que hacer dispnibles lo que vienen siendo estás rutas:

	// ruta para el home 
	app.use("/", (req, res) => {
		res.send("Hola");
	});

	app.use("/nosotros", (req, res) => {
		res.send("Hola");
	});

Todo este contenido, lo que está aquí, hacerlo disponible hacia
acá (./index.js).

Y si has utilizado la nueva sintaxis de ES6, usualmente se utiliza
export default y luego el nombre del objeto, de la función que vas a
exportar.

De nueva cuenta esta sintaxis, no es soportada de forma nativa, NO!
Pero a module.exports:

const express = require("express");
const router = express.Router();

module.exports = function() {
    // ruta para el home 
    router.get("/", (req, res) => {
        res.send("Index");
    });

    router.get("/nosotros", (req, res) => {
        res.send("Nosotros");
    });
	return router;
};

Entonces cuando yo entre en la página principal o en 
/nosotros, por medio de GET, se van a mostrar Index o Nosotros.

importar rutas en ./index.js
-----------------------------
const routes = require("./routes");

No es necesario poner el index.js, por que se da por implícito de que
se va a importar.

Luego agregamos:
	app.use("/", routes());

- routes va con paréntesis por que lo que importamos desde routes, es 
una función:

const express = require("express");
const routes = require("./routes");

// crear un app de express
const app = express();

app.use("/", routes());

app.listen(3000);

Y de esta forma podemos crear múltiples páginas e ir accediendo
a <> secciones, crear un sitio web con múltiples secciones o 
una aplicación con <> secciones.

Puedes ver que tenemos nuestro archivo de rutas, y tenemos
este request y response (req y res), y nos dice que se tiene que 
mostrar.

Eso en el MVC es obligación del Controller, no es obligación de 
la ruta.

Por lo tanto en el siguiente video vamos a crear la parte 
de los controladores, para definir esta estructura que tenemos
aquí.

Que es Model View Controller - MVC
-------------------------------------------
intro
------
Los proyectos desarrollados en este curso utilizan el patrón MVC,
lo que se conoce como Model View Controller, en español 
Modelo Vista Controlador.

Veamos brevemente que és Model View Controller (MVC).
Es un patrón de diseño de software que permite la separación de 
aplicaciones, así se le conoce a cada pieza, que tiene como 
una obligación, y solamente se dedica a cumplir esa obligación.

Con <> de otras formas de escribir código, en la que la consulta a la
BD, el código PHP por ejemplo y el HTML se revuelven, en el MVC no se
hace de esa forma. 

Cada pieza es separada, cada pieza realiza una función, y solamente esa,
y bueno se realiza en tu aplicación web.

Acá dice en tu aplicación web, por que el curso se enfoca a desarrollo web,
pero también hay MVC para desarrollo de aplicaciones mobiles por ejemplo.

Enfatiza la separación de la lógica de programación y lo que se muestra en una
pantalla, es decir lo que se muestra - los datos, son o se almacenan en una
vista, pero esos datos vienen de algo que se conoce como el modelo.

Entonces son 3 piezas, 

	Model es igual a Modelo,
	View es igual a la Vista, y 
	Controller es igual a Controlador.

Estare utilizando estos términos de forma o mejor dicho los estaré cambiando,
es decir, algunas veces me voy a referir a Model o a Modelo, es exactamente lo mismo.

Modelo
------
Primero veamos que es el Modelo o el Model. 
Es el encargado de los datos - usualmente viene de una BD, por lo tanto es en el 
Modelo donde realizas las consultas y de toda la lógica para mostrar esos datos.

Es decir, el modelo va a contar con una serie de métodos para realizar la consulta
a la BD, pero también es el que le da la forma a los sujetos, es decir si yo tengo,
un modelo para clientes, bueno voy a colocar ahí por ejemplo un Id, el nombre del 
cliente, que tipo de cliente es y en que categoría esta; alguna imagen del cliente,
su teléfono de contacto, toda la forma del objeto de clientes se la va a dar el 
modelo.

Veamos un ejemplo...
Supongamos que un usuario visita la sección de productos, que es una tienda virtual.
Ahí hay muchas cosas que suceden, es decir, el modelo va a encargarse de realizar 
la consulta, pero toda la parte visual es algo que lo hace la vista, entonces 
ahí tenemos un poco la separación de obligaciones.

El modelo únicamente se encarga de traer los datos desde la BD, mientras que lo que
se ve en pantalla, corresponde a lo que se conoce como la vista.

Vista
------
La vista es la que se encarga de todo lo que se ve en la pantalla (HTML), es 
decir todo el HTML.

Ejemplo:
y bueno volviendo al ejemplo anterior, si el modelo hace la consulta a la BD, 
se traen los resultados de la BD para los productos. 
Es la vista la que muestra esos resultados, es el HTML, es la parte visual.


Controller
------------
Y finalmente tenemos el Controller. 
Es el que se comunica entre el Modelo y la Vista, muy importante.
Es decir tu visitas /productos, se comunica con el modelo y dice: 
"oye un usuario esta visitando productos, pasame todos los productos,
y lo que viene siendo el modelo se regresa al controlador".

Dice: "acá están los productos", y el controlador se lo pasa hacia la vista
para que se vean.

Se puede decir como la persona en medio, es lo que comunica, lo que viene
siendo los datos de la BD, ya con lo que se ve en el HTML.

Es como lo que esta ahí a medias, como el medio de comunicación entre ambos.

Y bueno antes de que el modelo consulte la BD, es el encargado de mandar
a llamar el modelo, y decirle o esperar a que tenga los resultados, y el 
modelo una vez que tiene los resultados de la consulta a la BD, se los
regresa, lo que viene siendo el controlador para que éste los pase hacia
la vista.

Router
--------
Un término que se menciona poco, en MVC, pero en express se utiliza mucho
y otros frameworks como Laravel, es el Router, o lo que viene siendo
las URLs reales de un sitio web.

Es el encargado de registrar todas las URLs's o endpoints que soporta
tu aplicación, y en base a que el usuario visite esas URL's, se realizan
ciertas acciones. 

Por ejemplo, si el usuario accede a /productos, bueno el Router manda a llamar
al controlador, le dice, alguien esta visitando, haciendo uso de la aplicación,
es tu problema que pase de aquí en adelante.

El controlador se comunica con el modelo, le dice que es lo que tiene que 
consultar, obtiene los datos del modelo, que se pasan de regreso hacia el controlador,
es decir, controlador y modelo para mandarlo a llamar y después obtener los datos;
y finalmente es el controlador quien le pasa los datos hacia la vista para
que se muestren.

Creando el Controlador de los Proyectos
-------------------------------------------
Vamos a crear la parte del controlador que nos va a mostrar, lo que viene siendo
el index y nosotros.

Aquí en la raíz del proyecto voy a crear una nueva carpeta que voy a nombrar como
controllers.

El controlador es lo que va a estar en la parte de a medias, por así decirlo,
del modelo y de lo que viene siendo la vista... El controlador es lo que conecta
a ambas partes.

En este caso nuestro Router (./routes/index.js), puedes ver que definimos las rutas,
pero también esta parte de código, la segunda parte de lo que viene siendo el router,
nos dice que se va a mostrar, en la parte del HTML, esto es obligación del controlador.

Creamos el archivo proyectosController.js en ./controllers: 

exports.proyectosHome = (req, res) => {
    res.send("Index");
};

Luego importamos proyectosController en ./routes/index.js:

const express = require("express");
const router = express.Router();

// importar el controlador
const proyectosController = require("../controllers/proyectosController");

module.exports = function() {
    router.get("/", proyectosController.proyectosHome);

    router.get("/nosotros", (req, res) => {
        res.send("Nosotros");
    });
    return router;
};

De esta forma lo que viene siendo tu Router, funciona únicamente como router,
y el controlador es el que define, que se va a ver, que se va a mostrar, en 
lo que viene siendo el HTML, que de momento solamente tenemos estos send()
pero la idea es ir agregando vistas ...

Y para ver algo diferente, que no sea nada más ese texto, tenemos que
configurar lo que viene siendo la parte de las vistas del MVC. 

Así que en el siguiente video vamos a configurar las vistas.

Este primer proyecto esta hecho con PUG, así que continuamos en el próximo video.

Qué es el Template Engine
-------------------------------------------
En este vídeo vamos a ver que son los Template Engines o también se les conoce cómo
motores de plantilla.

¿Qué son?
Son la V (Vista) del MVC.

Permiten mostrar la parte visual (HTML) en una aplicaciones express - y bueno en realidad
en cualquier otro framework que decidas utilizar, casi todos tienen su propio Template Engine.

Debido a que el modelo retorna un objeto ( o también puede ser un arreglo ) de datos, 
un Template Engine te va permitir acceder a los resultados de una consulta y también
mostrarlos en la pantalla.

Caract. de un Template Engine
----------------------------------
Hay una gran variedad y c/u tiene su propia sintaxis.
Usualmente puedes escribir código JS dentro del HTML 
   - es decir, si hiciste una consulta por ejemplo para productos, la obtuviste del modelo,
     los datos en el controlador lo pasa a la vista, y tienes 100 productos ... puedes
	 iterar en esos 100 productos en lo que viene siendo la vista, con un for each,
	 y es un código JS, e ir imprimiendo el resultado de esa consulta en lo que 
	 viene siendo tu vista al final. 
	 Se puede decir que se "compila" y termina siendo un código HTML plano, 
	 pero en la parte de desarrollo termina siendo de gran ayuda porque
	 simplifica mucho como se van a imprimir los datos.
Si tienes experiencia en Angular, Reac o Vue, usualmente reemplazan estos 
Template Engines en una aplicación de Node.

Lo más comunes en Node-Express
----------------------------------
PUG ( Antes JADE )
   - Bastante limpio en la forma en la que queda el template
EJS - Embedded JavaScript
HBS - Handlebars.js (Mustache.js)
   - Este era como un sistema de templates en JavaScript bastante común
     hace muchos años, y hoy en día sigue siendo bastante popular.
     Se fusiona con Mustache.js - que también es bastante bueno, 
	 entonces son excelentes opciones.
     Todos los proyectos están hechos con algunos de estos, la idea es que
     te sientas familiarizado con alguno de ellos, aprendas, veas con cual
     te siente más cómodo escribiendo código, aprendas sobre todo los 3, y 
     de ahí tu decidas cual crees que es el mejor.
- React 
   - También existe un Template Engine para React que es bastante común.

Un Template Engine se instala vía npm
---------------------------------------
   npm install pug

y se habilita en el archivo principal
   // habilitar pug
   app.set("view-engine", "pug");

   El 2do parámetro dice "pug", pero puede cambiar ... depende el Template que
   hayas decidido utilizar, puede que sea pug como en este caso, puede que
   sea hbs, o también puede que sea ejs.

Finalmente veamos un poco la sintaxis de cada uno.

Ejemplo PUG
-------------

   if tareas.length
      each tarea in tareas
	       li.tarea(data-tarea=`${tarea.id}`)
		      p= tarea.tarea

	Etiquetas de apertura y cierre generadas automáticamente.

Ejemplo Handlebars
-------------------
	<div class="caja">
		<p class="etiqueta">Empresa</p>
		<p class="nombre">{{ vacante.empresa }}</p>  
	</div>
	<div class="caja">
		<p class="etiqueta">Ubicación</p>
		<p class="nombre">{{ vacante.ubicacion }}</p>  
	</div>

	Etiquetas de aperturas y cierre son necesarias.
	Lo que es dinámico lo ponemos dentro de estas dobles llaves, y 
	después el nombre del objeto para ir imprimiendo c/u de ellos.

Esta sintaxis se puede sentir un poco más familiar en la parte del HTML.

Ejemplo EJS
-------------
	<div class="informacion-usuario">
		<div class="imagen">
			<% if (usuario.imagen) { %>
				<img src="/uploads/perfiles/<%= usuario.imagen %>" />
			<% } %>   
		</div>
		<div class="texto">
			<%- usuario.descripcion %>
		</div>
	</div>

Nota como en este caso sigue siendo el HTML con etiqueta de apertura y cierre.
Pero x ejemplo digamos esta parte que esta debajo de esta div class="texto"
ahi tenemos <%- usuario.descripcion %>, usuario es el objeto principal,
pero nota esta sintaxis de menor que, luego porcentaje, luego un guión medio,
Eso es lo que va a decir, bueno ignora que esto sea un HTML, esto es una 
variable de JS, imprimimelo como tal, es dinámico, viene de la BD, imprimelo
como tal.

Ahora nota por ejemplo esa parte que dice usuario.descripcion como tiene un guión
medio, y arriba el if no lo tiene. 

Cuando le colocas un guión medio o un signo de igual eso quiere decir imprimelo,
cuando no colocas nada eso quiere decir evalúa el código JS; y nota como 
evaluamos si hay una imagen, entonces imprimimos la imagen.

Y nota como por ejemplo aquí donde dice usuario.imagen tenemos un signo igual.

La <> entre esto 2, guión medio y signo igual, en realidad no es mucha.
Uno se conoce como están los datos escapados, y el otro no.

Finalmente el curso incluye:
Cada proyecto hecho con un template engine diferente.
   -- El 1° esta hecho en PUG
   -- El 2° con Handlebars
   -- El 3° esta hecho con EJS

Finalmente tendremos algo de React pero no como Template Engine.

Con todos puedes lograr / mostrar lo mismo, así que utiliza 
el que se sienta más natural.

Una vez que hayas finalizado el curso y finalmente si quieres leer
un poco más, en esta URL hay una gran cantidad de Template Engine
soportados por express:

https://github.com/expressjs/express/wiki#template-engines

https://expressjs.com/en/resources/template-engines.html

No hay nada más que 3, son como 20, pero estos son lo más comunes 
hoy en día.

Instalando Pug y habilitando las Vistas en Express
------------------------------------------------------
Actualmente sino en nuestro sitio web abrimos nosotros o abrimos
la página de inicio, solamente tenemos este texto:

Inicio

Estamos utilizando lo que viene siendo .send():
	exports.proyectosHome = (req, res) => {
		res.send("Index");
	};

, y .send() solamente va a mostrar lo que este dentro del paréntesis().

Si tu proyecto va a crecer y quieres que se vea más atractivo a la vista,
lo más seguro es que quieras agregar algo de HTML, CSS.

Y la forma en que lo haces es agregando la parte, ya tenemos el controlador,
tenemos que agregar la parte de las vistas.

Y existen muchas formas de agregar vistas en express.

Casi siempre se utiliza un lenguaje de template, un template engine.
Existen una gran variedad que puedes utilizar con express.
Puedes ver en esta lista, tienes todos estos que están aquí, de los que
puedes utilizar con express:

https://expressjs.com/en/resources/template-engines.html

En este curso estaremos utilizando estos 3:
- Pug
- EJS
- Handlebars

En mi opinión son los 3 más comunes, más populares, y existe buena
posibilidad de que si te toca mantener un proyecto de express, 
o alguien ha iniciado algo, cualquiera de estas 3 sea la opción que 
hayan decidido utilizar.

instalando pug
--------------
Primero tenemos que instalar pug, para eso vamos a detener el servidor
en lo que es la consola y escribimos:

   npm install --save pug

   (va a hacer una dependencia del proyecto)

Una vez se haya terminado de instalar, volvemos a correr el servidor con:
   npm run start

haciendo algunas modificaciones (./index.js)
-------------------------------
Después tenemos que abrir el archivo - ./index.js,
si recuerdas mencioné que este archivo, en el vamos a estar trabajando,
y es como el archivo de configuración.

Y esta vez vamos a agregar 2 cosas:

1°) Vamos a habilitar pug como el view-engine
2°) Vamos a agregar la carpeta de las Vistas

Muy importante, puedes ver que aquí dice crear una app en express:

	// crear un app de express
	const app = express();

, por tanto debe de ser después de esta línea:

	// Habilitar pug
	app.set("view engine", "pug");

Ahora creamos la carpeta views en la raíz del proyecto (./views),
y con esto ya tenemos las carpeta controllers y views listas, solo nos faltan
los modelos, eso lo veremos mucho más adelante.

Para poder decirle a express que queremos leer esta carpeta, 
tengo que importar algo llamado el path:

	const path = require("path");

path es una librería que ya existe en node, por lo tanto no tienes 
que instalar nada; y path lo que hace es leer lo que se conoce como 
el file system, es decir los archivos que existen en tu carpeta - 
es una forma de acceder a ellos, y aquí le decimos que lo agregue 
a la vistas:

	// Añadir la carpeta de las vistas
	app.set("views", path.join(__dirname, "./views"));

__dirname: nos va a retornar el directorio principal - que vendría
siendo en donde esta el ./index.js.

pruebas sobre ./views
-------------------------------
Agregamos una vista en ./views que se llame index.pug -
muy importante tiene que ser punto pug, no se va a utilizar 
.html, ni nada de eso ... se va a utilizar .pug para crear 
lo que vienen siendo los templates. 

Rellenamos index.pug con:

h1 Hola

En ./controllers/proyectosController.js, vamos a utilizar 
el método .render() en lugar del .send() - como parámetro recibe
el nombre de la vista:

exports.proyectosHome = (req, res) => {
    res.render("index");
};

Eliminando ruta ./nosotros
-----------------------------
Eliminamos la ruta hacia ./nosotros del archivo ./routes/index.js:

    router.get("/nosotros", proyectosController.nosotros);

La eliminamos también del controller (./controllers/proyectosController.js):

	exports.nosotros = (req, res) => {
		res.send("Nosotros");
	};

lo que sigue
-------------
En el siguiente video veremos como crear lo que se como conoce
como una Master Page, es decir una página principal que va a
tener toda la parte del HTML para el header, los scripts, 
enlace a hojas de estilo, entre otras cosas. 

Es decir creamos el layout principal.

Creando un Master Page
------------------------------------------------------
En el vídeo anterior ya hemos habilitado lo que son las vistas
en nuestro proyecto.

Ahora veamos la importancia de 2 cosas:

1°) Por que crear un Master Layout
2°) También veremos la parte de los archivos públicos

primeros pasos
---------------
Primero vamos a abrir lo que vienen siendo los routes, y puedes
ver que es nuestro controlador, tenemos lo que viene siendo
la página principal, agreguemos una ruta a /nosotros:

    router.get("/nosotros", (req, res) => {
        res.render("nosotros");
    });

y ahora creemos la vista nosotros.pug dentro de la carpeta ./views,
con el siguiente contenido:

h1 Nosotros

En ./views/index.pug reemplazamos su contenido por el siguiente:
h1 Index

importancia del layout
-----------------------
Es importante definir un Layout o un Master Page, por que supongamos
que en index.pug, pones un ! (signo de exclamación), más un TAB,
te agrega un HTML, y entonces agregamos una hoja de estilo,
suponiendo que tiene algo así como un link (por ej a bootstrap.css),
tendría que hacer eso mismo en todos tus archivos.

Eso a la larga no es fácil de mantener, porque si tienes 50 vistas, y 
te piden agregar una nueva hoja de estilo, tendrás que hacerlo 50 veces,
pero si te dicen que la quites tendrás que hacer lo mismo 50 veces.

Y esto se soluciona muy fácilmente con algo llamado Layout o Master Page.

Es muy sencillo de crear y veremos sus ventajas.

creando el layout
-------------------
En la raíz de la vistas vamos a crear un nuevo archivo llamado 
layout.pug.

Nota aparte, recién utilizamos el signo de exclamación más un TAB,
y nos deplegó todo un snippet inicial de la estructura HTML
de una página.

Para poder utilizar otros snippets, en VS Code -- Extensions, 
buscamos e instalamos la siguiente extensión:

Pug/Jade snippets for VS Code

doctype html
html(lang="en")
    head
        meta(charset="UTF-8")
        meta(http-equiv="X-UA-Compatible", content="IE=edge")
        meta(name="viewport", content="width=device-width, initial-scale=1.0")
        link(rel="stylesheet", href="./css/bootstrap.css")
        title Document
    body 
        block contenido

        block despuesContenido

archivo ./views/nosotros.pug
extends layout 

block contenido
    h1 Nosotros

block despuesContenido
    h2 Yo voy después del contenido    

archivo ./views/index.pug
extends layout 

block contenido
    h1 Inicio

para terminar el video
-----------------------
el archivo ./views/nosotros.pug lo voy a eliminar, solo 
lo utilize para mostrarles las ventajas de utilizar una Master Page.

También eliminamos la referencia a la vista nosotros desde 
./routes/index.js:

    router.get("/nosotros", (req, res) => {
        res.render("nosotros");
    });

En ./views/layout.pug eliminamos el bloque despuesContenido.

sobre los recursos de este video
---------------------------------
Puedes ver que en los recursos del vídeo deje un archivo llamado
public.zip.

Esta carpeta hay que abrirla, luego abrir nuestro proyecto,
y moverla hacia el mismo.

Puedes que nuestro proyectos ya tendremos:
	- controllers
	- un public
	- un routes 
	- y un views 

Usualmente en esta carpeta de public vas a colocar tus archivos 
de JavaScript, CSS, imagenes, etc, 

En ./public/css vas a encontrar 2 archivos:
	- app.css
	- normalize.css

Entonces desde ./views/layout.pug vamos a hacer referencia a estos 2 
archivos:

	link(rel="stylesheet", href="/css/normalize.css")
	link(rel="stylesheet", href="/css/app.css")

Si guardamos cambios y recargamos, puedes ver que no los toma,
incluso si abres aquí tu consola te van a aparecer un par de errores:

Refused to apply style from 'http://localhost:3000/css/normalize.css' because its MIME type ('text/html') is not a supported stylesheet MIME type, and strict MIME checking is enabled.
Refused to apply style from 'http://localhost:3000/css/app.css' because its MIME type ('text/html') is not a supported stylesheet MIME type, and strict MIME checking is enabled.

Te va a decir que no encuentra ni:
	- normalize.css
	- app.css

Y eso es por que tenemos que ir al archivo de configuración de node, 
y decirle en que carpeta va a encontrar esos archivos.

Así que todo eso lo veremos en el próximo video.

Habilitando los Archivos Estáticos y finalizndo el Master Page
----------------------------------------------------------------------
En el vídeo anterior agregamos lo que viene siendo tanto normalize.css como 
app.css.

- normalize.css: nos va a resetear algunos estilos por default de los navegadores.
- app.css: contiene los estilos para este proyecto.

Para no estar escribiendo todo el css, ya lo incluí como material del curso.

Pero puedes que nos aparece un error, nos dice que no encuentra lo que 
viene siendo estas carpetas - las agregamos en la carpeta public, es 
una recomendación, es como una convención que hay de nombrarla como 
public, pero tu puedes nombrarla com otu desees. 

Por que tienes que decirle a node en que parte va a encontrar esos archivos, y eso
lo haces de nueva cuenta en el ./index.js.

Aquí después de crear la aplicación de express, vamos a decirle
donde cargar los archivo estáticos:

	// Donde cargar los archivos estáticos
	app.use(express.static("public"));

finalizando la Master Page
---------------------------
./views/layout.pug
doctype html
html(lang="en")
    head
        meta(charset="UTF-8")
        meta(http-equiv="X-UA-Compatible", content="IE=edge")
        meta(name="viewport", content="width=device-width, initial-scale=1.0")
        link(rel="stylesheet", href="./css/normalize.css")
        link(rel="stylesheet", href="./css/app.css")
        //- title= nombrePagina
        title #{nombrePagina}
    body 
        header.barra 
            h1 UpTask - Administrador de Proyectos 
            a(href="#") Cerrar Sesión

        main.contenedor
            aside.contenedor-proyectos
                .panel.crear-proyecto
                    a(href="#" class="boton") Nuevo Proyecto
                        span +
                .panel.lista-proyectos
                    h2 Proyectos 
                    ul#proyectos.proyectos
                        li
                            a(href="#") Diseño de Tienda Virtual
                        li
                            a(href="#") Diseño de Nuevo Blog
                        li
                            a(href="#") Diseño de Tienda Logotipo                            
            
            block contenido

para cambiar el titulo del layout
----------------------------------
En ./controllers/proyectosController.js:

	exports.proyectosHome = (req, res) => {
		res.render("index", {
			nombrePagina: "Proyectos"
		});
	};

En el método render() usamos el 2° parámetro, el cual recibe un objeto.
En este caso le pasamos la propiedad nombrePagina.

Luego desde ./views/layout.pug para referenciarlo se puede 
hacer de 2 formas:

1°) Usando el signo igual espacio y el nombre de la propiedad, luego de title

	title= nombrePagina

2°) Usando # y entre llaves poner el nombre de la propiedad, luego de title

	title #{nombrePagina}

lo que sigue
-------------
Puedes ver que agregamos este botón de Nuevo Proyecto.
No hace nada de momento, por que si abrimos lo que viene siendo el 
layout, pero ver que nada más dice aquí, en el href="#":

	a(href="#" class="boton") Nuevo Proyecto
		span +

Tenemos que crear una nueva ruta en ./routes/index.js, y 
crear una nueva vista.

Veamos como hacer esa parte en el próximo video.

Creando la sección para Nuevos Proyectos
------------------------------------------
Continuemos con nuestro proyecto, vamos a abrir ./views/layout.pug,
aquí donde tenemos este botón que dice Nuevo Proyecto, el enlace aún
no funciona:
	.panel.crear-proyecto
		a(href="#" class="boton") Nuevo Proyecto
			span +

tiene el signo de gato (#) solamente para simular el enlace, así 
que vamos a ponerle entre comillas /nuevo-proyecto:
	.panel.crear-proyecto
		a(href="#" class="boton") Nuevo Proyecto
			span +

Si guardamos y vamos http://locahost:3000/ y hacemos clic en Nuevo Proyecto,
vemos que nos devuelve que no puede encontrar esa ruta:

Cannot GET /nuevo-proyecto

Eso pasa por que cuando creas nuevas rutas así, tienes que ir al router,
y definir también esas rutas para que express sepa que existen.

Entonces en ./views/layout.pug, colocamos la ruta hacia /nuevo-proyecto:
	.panel.crear-proyecto
		a(href="./nuevo-proyecto" class="boton") Nuevo Proyecto
			span +

Luego vamos a ./routes/index.js y también incluimos la ruta:

	module.exports = function() {
		router.get("/", proyectosController.proyectosHome);
		router.get("/nuevo-proyecto", proyectosController.formularioProyecto);
		return router;
	};

En ./controllers/proyectosController.js:
	exports.formularioProyecto = (req, res) => {
		res.render("nuevo-proyecto", {
			nombrePagina: "Nuevo Proyecto"
		});
	};

En ./views vamos a crear un archivo nuevo: 
	- nuevo-proyecto.pug

En nuevo-proyecto.pug poner el siguiente contenido:
extends layout 

block contenido
    .contenido-principal
        h1 #{nombrePagina}

En index.pug para dejarlo similar a nuevo-proyecto.pug colocamos 
lo siguiente:

extends layout 

block contenido
    .contenido-principal
        h1 #{nombrePagina}

para finalizar
---------------
Entonces cada vez que hay que agregar una nueva ruta son 3 cosas las 
que tenemos que tener en cuenta:

	- 1°) Agregarlo en el routes (./routes/index.js)
	- 2°) Definir la parte del controlador
	- 3°) Agregar la vista

Tenemos lista ya la nueva vista para ./nuevo-proyecto, nos hace
falta un formulario. 

Todo eso lo veremos en el próximo video.